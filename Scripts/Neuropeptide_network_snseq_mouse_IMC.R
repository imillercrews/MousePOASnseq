#### Mouse snseq seurat analysis
### Neuropeptide network 
###Note: Seurat requires R version > 4
## use lambcomp1 to run R with command 
# > R-4.0.3

### set working directory
setwd("/stor/work/Hofmann/All_projects/Mouse_poa_snseq/seurat/")

#### load libraries ####
##install libraries
# install.packages("tidyverse",
#                  repos = "https://cloud.r-project.org")
# install.packages("Seurat",
#                  repos = "https://cloud.r-project.org")
# install.packages("patchwork",
#                  repos = "https://cloud.r-project.org")
#install.packages('BiocManager')
#BiocManager::install('multtest')
# install.packages('metap',
#                  repos = "https://cloud.r-project.org")
# install.packages('clustree')
# if (!requireNamespace("BiocManager", quietly=TRUE))
#   install.packages("BiocManager")
# BiocManager::install("DEsingle")
# install.packages("mathjaxr")
# # install older version of metan that works with R 4.0.3
# install.packages("https://cran.r-project.org/src/contrib/Archive/metan/metan_1.16.0.tar.gz",
#                  repos=NULL,
#                  type="source")
# install.packages('ecodist')


#load libraries
library(sp)
library(SeuratObject)
library(Seurat)
library(ggraph)
library(patchwork)
library(clustree)
library(pheatmap)
library(DEsingle)
library(igraph)
library(ggridges)
library(forcats)
library(metan)
library(ecodist)
library(tidyverse)
library(ggrepel)

#### load data ####
### load single cell data combined
load('mouse.snseq.combined.sct.RData')

## select neurons
#set idents
Idents(object = mouse.snseq.combined.sct) <- "parent_id.broad.prob"

#subset to neurons
mouse.snseq.combined.sct.neurons = subset(mouse.snseq.combined.sct,
                                          idents = c("C7-2: GABA",
                                                     "C7-1: GLU"))

# subset with SCT data
DefaultAssay(mouse.snseq.combined.sct.neurons) = 'SCT'

### load neuropeptide list 
neuropeptides = read.csv('./gene.lists/neuropeptides.list.csv')
# genes
neuropeptides.genes = neuropeptides %>% 
  pull(Gene.name)

#### functions ####
### create remove_nonexp
## from: https://almeidasilvaf.github.io/BioNERO/reference/remove_nonexp.html 
#' Remove genes that are not expressed based on a user-defined threshold
#'
#' @param exp A gene expression data frame with genes in row names
#' and samples in column names or a `SummarizedExperiment` object.
#' @param method Criterion to filter non-expressed genes out.
#' One of "mean", "median", "percentage", or "allsamples". Default is "median".
#' @param min_exp If method is 'mean', 'median', or 'allsamples',
#' the minimum value for a gene to be considered expressed.
#' If method is 'percentage', the minimum value each gene must have in
#' at least n percent of samples to be considered expressed.
#' @param min_percentage_samples In case the user chooses 'percentage' as method,
#' expressed genes must have expression >= min_exp in at least this percentage.
#' Values must range from 0 to 1.
#'
#' @return Filtered gene expression data frame or `SummarizedExperiment` object.
#' @author Fabricio Almeida-Silva
#' @export
#' @importFrom matrixStats rowMedians
#' @seealso
#'  \code{\link[matrixStats]{rowMedians}}
#'  \code{\link[WGCNA]{goodSamplesGenes}}
#' @rdname remove_nonexp
#' @examples
#' data(zma.se)
#' filt_exp <- remove_nonexp(zma.se, min_exp = 5)
remove_nonexp <- function(exp, method="median", min_exp=1, min_percentage_samples=0.25) {
  # fexp <- handleSE(exp)
  fexp <- exp
  
  if(method == "median") {
    final_exp <- fexp[matrixStats::rowMedians(as.matrix(fexp)) >= min_exp,]
  } else if (method == "mean") {
    final_exp <- fexp[rowMeans(fexp) >= min_exp,]
  } else if (method == "percentage") {
    min_n <- ncol(fexp) * min_percentage_samples
    final_exp <- fexp[rowSums(fexp >= min_exp) >= min_n, ]
  } else if (method == "allsamples") {
    final_exp <- fexp[rowSums(fexp >= min_exp) == ncol(fexp), ]
  } else {
    stop("No method specified. Please, choose a filtering method - mean, median or percentage")
  }
  
  # if(is(exp, "SummarizedExperiment")) {
  #   final_exp <- exp2SE(final_exp, exp)
  # }
  
  return(final_exp)
}


#### add pvalue to mantel test figure
#' Mantel test for a set of correlation matrices
#' @description
#' `r badge('stable')`
#'
#' This function generate a pairwise matrix of plots to compare the similarity
#' of two or more correlation matrices. In the upper diagonal are presented the
#' plots and in the lower diagonal the result of Mantel test based on
#' permutations.
#'
#'
#' @param ... The input matrices. May be an output generated by the function
#'   `lpcor` or a coerced list generated by the function `as.lpcor`
#' @param type The type of correlation if an obect generated by the function
#'   `lpcor` is used. 1 = Linear correlation matrices, or 2 = partial
#'   correlation matrices.
#' @param nrepet The number of permutations. Default is 1000
#' @param names An optional vector of names of the same length of `...` .
#' @param prob The error probability for Mantel test.
#' @param diag Logical argument. If `TRUE`, the Kernel density is shown in
#'   the diagonal of plot.
#' @param export Logical argument. If `TRUE`, then the plot is exported to
#'   the current directory.
#' @param main The title of the plot, set to 'auto'.
#' @param file.type The format of the file if `export = TRUE`.  Set to
#'   `'pdf'`. Other possible values are `*.tiff` using `file.type
#'   = 'tiff'`.
#' @param file.name The name of the plot when exported. Set to `NULL`,
#'   i.e., automatically.
#' @param width The width of the plot, set to `8`.
#' @param height The height of the plot, set to `7`.
#' @param resolution The resolution of the plot if `file.type = 'tiff'` is
#'   used. Set to `300` (300 dpi).
#' @param size.point The size of the points in the plot. Set to `0.5`.
#' @param shape.point The shape of the point, set to ` 19`.
#' @param alpha.point The value for transparency of the points: 1 = full color.
#' @param fill.point The color to fill the points. Valid argument if points are
#'   between 21 and 25.
#' @param col.point The color for the edge of the point, set to `black`.
#' @param minsize The size of the letter that will represent the smallest
#'   correlation coefficient.
#' @param maxsize The size of the letter that will represent the largest
#'   correlation coefficient.
#' @param signcol The colour that indicate significant correlations (based on
#'   the `prob` value.), set to 'green'.
#' @param alpha The value for transparency of the color informed in
#'   `signcol`, when 1 = full color. Set to 0.15.
#' @param diagcol The color in the kernel distribution. Set to 'gray'.
#' @param col.up.panel,col.lw.panel,col.dia.panel The color for the opper, lower
#'   and diagonal pannels. Set to 'gray', 'gray', and 'gray', respectively.
#' @param pan.spacing The space between the pannels. Set to 0.15.
#' @seealso [mantel_test()]
#' @param digits The number of digits to show in the plot.
#' @return An object of class `gg, ggmatrix`.
#' @author Tiago Olivoto \email{tiagoolivoto@@gmail.com}
#' @export
#' @examples
#'\donttest{
#' library(metan)
#' # iris dataset
#' lpc <- iris %>%
#'        group_by(Species) %>%
#'        lpcor() %>%
#'        pairs_mantel(names = c('setosa', 'versicolor', 'virginica'))
#'
#'
#' # mtcars dataset
#' mt_num <- select_numeric_cols(mtcars)
#' lpdata <- as.lpcor(cor(mt_num[1:5]),
#'                    cor(mt_num[1:5]),
#'                    cor(mt_num[2:6]),
#'                    cor(mt_num[4:8])) %>%
#'           pairs_mantel()
#'}
pairs_mantel.pvalue <- function (..., type = 1, nrepet = 1000, names = NULL, prob = 0.05, 
          diag = FALSE, export = FALSE, main = "auto", file.type = "pdf", 
          file.name = NULL, width = 8, height = 7, resolution = 300, 
          size.point = 0.5, shape.point = 19, alpha.point = 1, fill.point = NULL, 
          col.point = "black", minsize = 2, maxsize = 3, signcol = "green", 
          alpha = 0.15, diagcol = "gray", col.up.panel = "gray", col.lw.panel = "gray", 
          col.dia.panel = "gray", pan.spacing = 0.15, digits = 2) 
{
  class <- list(...)
  if (!type %in% c(1:2)) {
    stop("The argument type must be 1 (linear correlation) or 2 (partial correlation).")
  }
  if (sum(lapply(class, function(x) !any(class(x) %in% c("lpcor_group", 
                                                         "lpcor", "mahala_group", "covcor_design", "group_clustering", 
                                                         "clustering") == TRUE)) > 0)) {
    stop("The object must be of the class lpcor. Please use 'as.lpcorr' to convert correlation matrices into the correct format.")
  }
  if (any(class(...) == "lpcor_group")) {
    data <- lapply(...[[2]], function(x) {
      x[["linear.mat"]]
    })
  }
  if (any(class(...) == "group_clustering")) {
    data <- lapply(...[[2]], function(x) {
      x$distance
    })
  }
  if (!any(class(...) %in% c("lpcor_group", "group_clustering"))) {
    data <- lapply(..., function(x) {
      x
    })
  }
  w <- c(21:25)
  if (is.null(fill.point) == TRUE && any(w == shape.point)) {
    stop(call. = FALSE, "If 'shape.point' is a value between 21 and 25, you must provide a color for fill the shape using the argument 'fill.point.'")
  }
  for (i in 1:length(data)) {
    if (i == 1) {
      Dataset <- data.frame(var = as.vector(t(data[[1]])[lower.tri(data[[1]], 
                                                                   diag = FALSE)]))
      if (is.null(names)) {
        names(Dataset)[which(colnames(Dataset) == "var")] <- paste0("Matrix 1")
      }
      else {
        names(Dataset)[which(colnames(Dataset) == "var")] <- names[1]
      }
    }
    if (i >= 2) {
      Dataset <- mutate(Dataset, var = as.vector(t(data[[i]])[lower.tri(data[[i]], 
                                                                        diag = FALSE)]))
      if (is.null(names)) {
        names(Dataset)[which(colnames(Dataset) == "var")] <- paste0("Matrix ", 
                                                                    i)
      }
      else {
        names(Dataset)[which(colnames(Dataset) == "var")] <- names[i]
      }
    }
  }
  dim <- nrow(data[[1]])
  my_custom_cor <- function(data, mapping, color = I("black"), 
                            sizeRange = c(minsize, maxsize), ...) {
    x <- GGally::eval_data_col(data, mapping$x)
    y <- GGally::eval_data_col(data, mapping$y)
    D <- matrix(nrow = dim, ncol = dim)
    D[lower.tri(D, diag = FALSE)] <- x
    D <- make_sym(D, diag = 0)
    D2 <- matrix(nrow = dim, ncol = dim)
    D2[lower.tri(D2, diag = FALSE)] <- y
    D2 <- make_sym(D2, diag = 0)
    ct <- mantel_test(D, D2, nboot = nrepet)
    sig <- symnum(ct[[3]], corr = FALSE, na = FALSE, cutpoints = c(0, 
                                                                   0.001, 0.01, 0.05, 1), symbols = c("***", "**", 
                                                                                                      "*", ""))
    r <- ct[[1]]
    rt <- paste(format(r, digits = 2)[1],
                format(ct[[3]], digits = 2)[1],
                sep = ' , ')
    cex <- max(sizeRange)
    percent_of_range <- function(percent, range) {
      percent * diff(range) + min(range, na.rm = TRUE)
    }
    GGally::ggally_text(label = as.character(rt), mapping = aes(), 
                        xP = 0.5, yP = 0.5, size = I(percent_of_range(cex * 
                                                                        abs(r), sizeRange)), color = color, ...) + geom_text(aes_string(x = 0.8, 
                                                                                                                                        y = 0.8), label = sig, size = I(cex), color = color, 
                                                                                                                             ...) + theme_classic() + theme(panel.background = element_rect(color = col.lw.panel), 
                                                                                                                                                            axis.line = element_blank(), axis.ticks = element_blank(), 
                                                                                                                                                            axis.text.y = element_blank(), axis.text.x = element_blank())
  }
  my_custom_smooth <- function(data, mapping, ...) {
    x <- GGally::eval_data_col(data, mapping$x)
    y <- GGally::eval_data_col(data, mapping$y)
    D <- matrix(nrow = dim, ncol = dim)
    D[lower.tri(D, diag = FALSE)] <- x
    D <- make_sym(D, diag = 0)
    D2 <- matrix(nrow = dim, ncol = dim)
    D2[lower.tri(D2, diag = FALSE)] <- y
    D2 <- make_sym(D2, diag = 0)
    ct <- mantel_test(D, D2, nboot = nrepet)
    pval <- ct[[3]]
    p <- ggplot(data = data, mapping = mapping)
    if (is.null(fill.point) == FALSE) {
      p <- p + geom_point(color = I(col.point), fill = fill.point, 
                          shape = shape.point, size = size.point, alpha = alpha.point)
    }
    else {
      p <- p + geom_point(color = I(col.point), shape = shape.point, 
                          size = size.point, alpha = alpha.point)
    }
    p <- p + theme_classic() + theme(panel.background = element_rect(fill = "white", 
                                                                     color = col.up.panel), axis.line = element_blank(), 
                                     axis.ticks = element_blank(), axis.text.y = element_blank(), 
                                     axis.text.x = element_blank())
    if (pval < prob) {
      p <- p + theme(panel.background = element_rect(fill = ggplot2::alpha(signcol, 
                                                                           alpha)))
    }
    p
  }
  ggally_mysmooth <- function(data, mapping, ...) {
    ggplot(data = data, mapping = mapping) + geom_density(fill = alpha(diagcol, 
                                                                       1)) + theme_classic() + theme(panel.background = element_rect(fill = alpha("white", 
                                                                                                                                                  1), color = col.dia.panel))
  }
  if (main == "auto") {
    title <- paste0("Mantel's test with ", nrepet, " resamples")
  }
  else {
    title <- main
  }
  if (diag == TRUE) {
    diag <- list(continuous = ggally_mysmooth)
  }
  else {
    diag <- NULL
  }
  p1 <- GGally::ggpairs(Dataset, title = title, diag = diag, 
                        lower = list(continuous = my_custom_cor), upper = list(continuous = my_custom_smooth), 
                        axisLabels = "none") + theme(panel.spacing = grid::unit(pan.spacing, 
                                                                                "lines"))
  if (export == FALSE) {
    return(p1)
  }
  else if (file.type == "pdf") {
    if (is.null(file.name)) {
      pdf("Pairs of Mantel's test.pdf", width = width, 
          height = height)
    }
    else pdf(paste0(file.name, ".pdf"), width = width, height = height)
    print(p1)
    dev.off()
  }
  if (file.type == "tiff") {
    if (is.null(file.name)) {
      tiff(filename = "Pairs of Mantel's test.tiff", width = width, 
           height = height, units = "in", compression = "lzw", 
           res = resolution)
    }
    else tiff(filename = paste0(file.name, ".tiff"), width = width, 
              height = height, units = "in", compression = "lzw", 
              res = resolution)
    print(p1)
    dev.off()
  }
}

#### add confidence interval to mantel test figure
#' Mantel test for a set of correlation matrices
#' @description
#' `r badge('stable')`
#'
#' This function generate a pairwise matrix of plots to compare the similarity
#' of two or more correlation matrices. In the upper diagonal are presented the
#' plots and in the lower diagonal the result of Mantel test based on
#' permutations.
#'
#'
#' @param ... The input matrices. May be an output generated by the function
#'   `lpcor` or a coerced list generated by the function `as.lpcor`
#' @param type The type of correlation if an obect generated by the function
#'   `lpcor` is used. 1 = Linear correlation matrices, or 2 = partial
#'   correlation matrices.
#' @param nrepet The number of permutations. Default is 1000
#' @param names An optional vector of names of the same length of `...` .
#' @param prob The error probability for Mantel test.
#' @param diag Logical argument. If `TRUE`, the Kernel density is shown in
#'   the diagonal of plot.
#' @param export Logical argument. If `TRUE`, then the plot is exported to
#'   the current directory.
#' @param main The title of the plot, set to 'auto'.
#' @param file.type The format of the file if `export = TRUE`.  Set to
#'   `'pdf'`. Other possible values are `*.tiff` using `file.type
#'   = 'tiff'`.
#' @param file.name The name of the plot when exported. Set to `NULL`,
#'   i.e., automatically.
#' @param width The width of the plot, set to `8`.
#' @param height The height of the plot, set to `7`.
#' @param resolution The resolution of the plot if `file.type = 'tiff'` is
#'   used. Set to `300` (300 dpi).
#' @param size.point The size of the points in the plot. Set to `0.5`.
#' @param shape.point The shape of the point, set to ` 19`.
#' @param alpha.point The value for transparency of the points: 1 = full color.
#' @param fill.point The color to fill the points. Valid argument if points are
#'   between 21 and 25.
#' @param col.point The color for the edge of the point, set to `black`.
#' @param minsize The size of the letter that will represent the smallest
#'   correlation coefficient.
#' @param maxsize The size of the letter that will represent the largest
#'   correlation coefficient.
#' @param signcol The colour that indicate significant correlations (based on
#'   the `prob` value.), set to 'green'.
#' @param alpha The value for transparency of the color informed in
#'   `signcol`, when 1 = full color. Set to 0.15.
#' @param diagcol The color in the kernel distribution. Set to 'gray'.
#' @param col.up.panel,col.lw.panel,col.dia.panel The color for the opper, lower
#'   and diagonal pannels. Set to 'gray', 'gray', and 'gray', respectively.
#' @param pan.spacing The space between the pannels. Set to 0.15.
#' @seealso [mantel_test()]
#' @param digits The number of digits to show in the plot.
#' @return An object of class `gg, ggmatrix`.
#' @author Tiago Olivoto \email{tiagoolivoto@@gmail.com}
#' @export
#' @examples
#'\donttest{
#' library(metan)
#' # iris dataset
#' lpc <- iris %>%
#'        group_by(Species) %>%
#'        lpcor() %>%
#'        pairs_mantel(names = c('setosa', 'versicolor', 'virginica'))
#'
#'
#' # mtcars dataset
#' mt_num <- select_numeric_cols(mtcars)
#' lpdata <- as.lpcor(cor(mt_num[1:5]),
#'                    cor(mt_num[1:5]),
#'                    cor(mt_num[2:6]),
#'                    cor(mt_num[4:8])) %>%
#'           pairs_mantel()
#'}
pairs_mantel.ci <- function (..., type = 1, nrepet = 1000, names = NULL, prob = 0.05, 
                             diag = FALSE, export = FALSE, main = "auto", file.type = "pdf", 
                             file.name = NULL, width = 8, height = 7, resolution = 300, 
                             size.point = 0.5, shape.point = 19, alpha.point = 1, fill.point = NULL, 
                             col.point = "black", minsize = 2, maxsize = 3, signcol = "green", 
                             alpha = 0.15, diagcol = "gray", col.up.panel = "gray", col.lw.panel = "gray", 
                             col.dia.panel = "gray", pan.spacing = 0.15, digits = 2) 
{
  class <- list(...)
  if (!type %in% c(1:2)) {
    stop("The argument type must be 1 (linear correlation) or 2 (partial correlation).")
  }
  if (sum(lapply(class, function(x) !any(class(x) %in% c("lpcor_group", 
                                                         "lpcor", "mahala_group", "covcor_design", "group_clustering", 
                                                         "clustering") == TRUE)) > 0)) {
    stop("The object must be of the class lpcor. Please use 'as.lpcorr' to convert correlation matrices into the correct format.")
  }
  if (any(class(...) == "lpcor_group")) {
    data <- lapply(...[[2]], function(x) {
      x[["linear.mat"]]
    })
  }
  if (any(class(...) == "group_clustering")) {
    data <- lapply(...[[2]], function(x) {
      x$distance
    })
  }
  if (!any(class(...) %in% c("lpcor_group", "group_clustering"))) {
    data <- lapply(..., function(x) {
      x
    })
  }
  w <- c(21:25)
  if (is.null(fill.point) == TRUE && any(w == shape.point)) {
    stop(call. = FALSE, "If 'shape.point' is a value between 21 and 25, you must provide a color for fill the shape using the argument 'fill.point.'")
  }
  for (i in 1:length(data)) {
    if (i == 1) {
      Dataset <- data.frame(var = as.vector(t(data[[1]])[lower.tri(data[[1]], 
                                                                   diag = FALSE)]))
      if (is.null(names)) {
        names(Dataset)[which(colnames(Dataset) == "var")] <- paste0("Matrix 1")
      }
      else {
        names(Dataset)[which(colnames(Dataset) == "var")] <- names[1]
      }
    }
    if (i >= 2) {
      Dataset <- mutate(Dataset, var = as.vector(t(data[[i]])[lower.tri(data[[i]], 
                                                                        diag = FALSE)]))
      if (is.null(names)) {
        names(Dataset)[which(colnames(Dataset) == "var")] <- paste0("Matrix ", 
                                                                    i)
      }
      else {
        names(Dataset)[which(colnames(Dataset) == "var")] <- names[i]
      }
    }
  }
  dim <- nrow(data[[1]])
  my_custom_cor <- function(data, mapping, color = I("black"), 
                            sizeRange = c(minsize, maxsize), ...) {
    x <- GGally::eval_data_col(data, mapping$x)
    y <- GGally::eval_data_col(data, mapping$y)
    D <- matrix(nrow = dim, ncol = dim)
    D[lower.tri(D, diag = FALSE)] <- x
    D <- make_sym(D, diag = 0)
    D2 <- matrix(nrow = dim, ncol = dim)
    D2[lower.tri(D2, diag = FALSE)] <- y
    D2 <- make_sym(D2, diag = 0)
    ct <- mantel_test(D, D2, nboot = nrepet)
    ct.2 <- ecodist::mantel(as.dist(D) ~ as.dist(D2), nboot = nrepet) # use mantel test from ecodist to get confidence interval
    sig <- symnum(ct[[2]], #change to get p-value
                  corr = FALSE, na = FALSE, cutpoints = c(0, 
                                                          0.001, 0.01, 0.05, 1), symbols = c("***", "**", 
                                                                                             "*", ""))
    r <- ct[[1]]
    rt <- paste(format(ct.2[[2]], digits = 2)[1],
                " , ",
                format(ct.2[[1]], digits = 2)[1],
                ' , ',
                format(ct.2[[5]], digits = 2)[1], # add lower confidence interval
                '-',
                format(ct.2[[6]], digits = 2)[1], # add upper confidence interval
                sep = '')
    cex <- max(sizeRange)
    percent_of_range <- function(percent, range) {
      percent * diff(range) + min(range, na.rm = TRUE)
    }
    GGally::ggally_text(label = as.character(rt), mapping = aes(), 
                        xP = 0.5, yP = 0.5, size = I(percent_of_range(cex * 
                                                                        abs(r), sizeRange)), color = color, ...) + geom_text(aes_string(x = 0.8, 
                                                                                                                                        y = 0.8), label = sig, size = I(cex), color = color, 
                                                                                                                             ...) + theme_classic() + theme(panel.background = element_rect(color = col.lw.panel), 
                                                                                                                                                            axis.line = element_blank(), axis.ticks = element_blank(), 
                                                                                                                                                            axis.text.y = element_blank(), axis.text.x = element_blank())
  }
  my_custom_smooth <- function(data, mapping, ...) {
    x <- GGally::eval_data_col(data, mapping$x)
    y <- GGally::eval_data_col(data, mapping$y)
    D <- matrix(nrow = dim, ncol = dim)
    D[lower.tri(D, diag = FALSE)] <- x
    D <- make_sym(D, diag = 0)
    D2 <- matrix(nrow = dim, ncol = dim)
    D2[lower.tri(D2, diag = FALSE)] <- y
    D2 <- make_sym(D2, diag = 0)
    ct <- mantel_test(D, D2, nboot = nrepet)
    pval <- ct[[3]]  
    p <- ggplot(data = data, mapping = mapping)
    if (is.null(fill.point) == FALSE) {
      p <- p + geom_point(color = I(col.point), fill = fill.point, 
                          shape = shape.point, size = size.point, alpha = alpha.point)
    }
    else {
      p <- p + geom_point(color = I(col.point), shape = shape.point, 
                          size = size.point, alpha = alpha.point)
    }
    p <- p + theme_classic() + theme(panel.background = element_rect(fill = "white", 
                                                                     color = col.up.panel), axis.line = element_blank(), 
                                     axis.ticks = element_blank(), axis.text.y = element_blank(), 
                                     axis.text.x = element_blank())
    if (pval < prob) {
      p <- p + theme(panel.background = element_rect(fill = ggplot2::alpha(signcol, 
                                                                           alpha)))
    }
    p
  }
  ggally_mysmooth <- function(data, mapping, ...) {
    ggplot(data = data, mapping = mapping) + geom_density(fill = alpha(diagcol, 
                                                                       1)) + theme_classic() + theme(panel.background = element_rect(fill = alpha("white", 
                                                                                                                                                  1), color = col.dia.panel))
  }
  if (main == "auto") {
    title <- paste0("Mantel's test with ", nrepet, " resamples")
  }
  else {
    title <- main
  }
  if (diag == TRUE) {
    diag <- list(continuous = ggally_mysmooth)
  }
  else {
    diag <- NULL
  }
  p1 <- GGally::ggpairs(Dataset, title = title, diag = diag, 
                        lower = list(continuous = my_custom_cor), upper = list(continuous = my_custom_smooth), 
                        axisLabels = "none") + theme(panel.spacing = grid::unit(pan.spacing, 
                                                                                "lines"))
  if (export == FALSE) {
    return(p1)
  }
  else if (file.type == "pdf") {
    if (is.null(file.name)) {
      pdf("Pairs of Mantel's test.pdf", width = width, 
          height = height)
    }
    else pdf(paste0(file.name, ".pdf"), width = width, height = height)
    print(p1)
    dev.off()
  }
  if (file.type == "tiff") {
    if (is.null(file.name)) {
      tiff(filename = "Pairs of Mantel's test.tiff", width = width, 
           height = height, units = "in", compression = "lzw", 
           res = resolution)
    }
    else tiff(filename = paste0(file.name, ".tiff"), width = width, 
              height = height, units = "in", compression = "lzw", 
              res = resolution)
    print(p1)
    dev.off()
  }
}

#' @name testCov
#' @aliases testCov
#' @title Testing the equality of two sample covariance matrices in high dimension.
#' @description Testing the equality of two sample covariance matrices in high dimension using different methods.
#'
#' @param X the n x p training data, could be a \code{matrix} or a \code{data.frame} object.
#' @param Y the n x p training data matrix, could be a \code{matrix} or a \code{data.frame} object.
#' @param method a string incidating the method for the test. The current available
#'        methods are \code{ALL}, \code{HD}, \code{LC}, \code{CLX}, \code{Scott}.
#' @param J the number of repetition in the test
#' @param alpha the significant level of the test.
#' @param n.core the number of cores to be used in parallel when \code{HD}
#'        is called.
#'
#'
#' @return
#'
#' For any single method, the function returns an \code{htest} object.
#'
#' For method \code{ALL}: A list of four \code{htest} objects.
#'
#' HD refers to "Chang, J., Zhou, W., Zhou, W.-X., and Wang, L. (2016). Comparing large covariance
#' matrices under weak conditions on the dependence structure and its application to gene
#'  clustering. Biometrics. To appear"#'
#'
#' CLX refers to "Cai, T. T., Liu, W., and Xia, Y. (2013).
#' Two-sample covariance matrix testing and support recovery in high-dimensional
#' and sparse settings. Journal of the American Statistical Association 108, 265-277."
#'
#' Sc refers to "Schott, J. R. (2007). A test for the equality of covariance
#' matrices when the dimension is large relative to the sample size.
#' Computational Statistics and Data Analysis 51, 6535-6542."
#'
#' @examples
#' data(GO54)
#' testCov(GO54$X, GO54$Y, method = "ALL", J = 100)
#' data(GO26)
#' testCov(GO26$X, GO26$Y, method = "ALL", J = 100)
#'
#' @author Tong He
#' @export
#'
#'
testCov = function(X, Y, method = "ALL", J = 2500, alpha = 0.05, n.core = 1) {
  DNAME = deparse(substitute(X))
  DNAME = paste(DNAME, "and", deparse(substitute(Y)))
  X = data.matrix(X)
  Y = data.matrix(Y)
  if (method == "HD") {
    res = testCovHD(X = X, Y = Y, J = J, alpha = alpha, DNAME = DNAME,
                    n.core = n.core)
    res = res[[1]]
  } else if (method == "LC") {
    res = equalCovs(X = X, Y = Y, DNAME = DNAME)
  } else if (method == "CLX") {
    res = testCovHD(X = X, Y = Y, J = 1, alpha = alpha, DNAME = DNAME,
                    n.core = 1)
    res = res[[2]]
  } else if (method == "Scott") {
    message("The method \'Scott\' does not support skewed data.")
    res = testCovHD(X = X, Y = Y, J = 1, alpha = alpha, DNAME = DNAME,
                    n.core = 1)
    res = res[[3]]
  } else if (method == "ALL") {
    res = testCovHD(X = X, Y = Y, J = J, alpha = alpha, DNAME = DNAME,
                    n.core = n.core)
    # nms = colnames(res)
    res2 = equalCovs(X = X, Y = Y, alpha = alpha, DNAME = DNAME)
    res = c(res, list(res2))
    # colnames(res) = c(nms, 'LC')
    message("The method \'Scott\' does not support skewed data.")
  } else {
    msg = paste0("method \'", method, "\' not available.")
    stop(msg)
  }
  return(res)
}


testCovHD = function(X, Y, J = 2500, alpha = 0.05, DNAME, n.core = 1) {
  checkmate::checkMatrix(X)
  checkmate::checkMatrix(Y)
  
  p = ncol(X)
  n1 = nrow(X)
  n2 = nrow(Y)
  if (ncol(Y) != p) {
    stop('Different dimensions of X and Y.')
  }
  
  tmp = rep(c(rep(1, n1)/n1, rep(1, n2)/n2), J)
  scalev = matrix(tmp, ncol = 1)
  
  qalpha = -log(8*pi) - 2*log(log(1/(1-alpha)))
  cri = 4*log (p)-log (log (p)) + qalpha
  
  
  Sx = cov(X)*(n1-1)/n1
  Sy = cov(Y)*(n2-1)/n2
  
  xa = t(t(X) - colMeans(X))
  ya = t(t(Y) - colMeans(Y))
  
  vx = t(xa^2)%*%(xa^2)/n1 - 2/n1 * (t(xa)%*% xa) * Sx + Sx^2
  vy = t(ya^2)%*%(ya^2)/n2 - 2/n2 * (t(ya)%*% ya) * Sy + Sy^2
  
  numo = abs(Sx-Sy)
  deno = sqrt(vx/n1 + vy/n2)
  Tnm = max(numo/deno)
  
  xat = t(xa)/n1
  yat = t(ya)/n2
  # g = rnorm((n1+n2)*J)*scalev
  
  # ts = matrix(0,J,1)
  scalev = c(rep(1, n1)/n1, rep(1, n2)/n2)
  if (n.core > 1) {
    # for (j in 1:J) {
    cl = makeCluster(n.core)
    registerDoParallel(cl)
    ts = foreach(j = 1:J, .combine = rbind) %dopar% {
      # ind1 = ((j-1)*(n1+n2)+1):((j-1)*(n1+n2)+n1)
      # ind2 = ((j-1)*(n1+n2)+n1+1):((j-1)*(n1+n2)+n2+n1)
      
      g = rnorm(n1+n2)*scalev
      atmp = sum(g[1:n1])
      btmp = sum(g[(n1+1):(n1+n2)])
      
      ts1 = (t(xa*g[1:n1]) - xat*atmp)%*% xa
      ts2 = (t(ya*g[(n1+1):(n1+n2)]) - yat*btmp)%*% ya
      
      # atmp = sum(g[ind1])
      # btmp = sum(g[ind2])
      
      # ts1 = (t(xa*g[ind1]) - xat*atmp)%*% xa
      # ts2 = (t(ya*g[ind2]) - yat*btmp)%*% ya
      #ts[j] = max(abs(ts1-ts2)/deno)
      max(abs(ts1-ts2)/deno)
    }
    stopCluster(cl)
  } else {
    ts = matrix(0,J,1)
    for (j in 1:J) {
      g = rnorm(n1+n2)*scalev
      atmp = sum(g[1:n1])
      btmp = sum(g[(n1+1):(n1+n2)])
      
      ts1 = (t(xa*g[1:n1]) - xat*atmp)%*% xa
      ts2 = (t(ya*g[(n1+1):(n1+n2)]) - yat*btmp)%*% ya
      
      # ind1 = ((j-1)*(n1+n2)+1):((j-1)*(n1+n2)+n1)
      # ind2 = ((j-1)*(n1+n2)+n1+1):((j-1)*(n1+n2)+n2+n1)
      #
      # atmp = sum(g[ind1])
      # btmp = sum(g[ind2])
      #
      # ts1 = (t(xa*g[ind1]) - xat*atmp)%*% xa
      # ts2 = (t(ya*g[ind2]) - yat*btmp)%*% ya
      ts[j] = max(abs(ts1-ts2)/deno)
    }
  }
  
  ZCZt = Tnm > quantile(ts, 1-alpha)
  CLX = max((Sx-Sy)^2/(vx/n1+vy/n2))
  # CLX = CLX-(4*log(p)-log(log(p)))
  
  Sxx = Sx*n1/(n1-1)
  Syy = Sy*n2/(n2-1)
  
  SsS = (Sxx*n1 + Syy*n2)/(n1+n2)
  eta1 = ((n1-1)+2)*((n1-1)-1)
  eta2 = ((n2-1)+2)*((n2-1)-1)
  d1 = (1-(n1-1-2)/eta1)*sum(diag(Sxx%*%Sxx))
  d2 = (1-(n2-1-2)/eta2)*sum(diag(Syy%*%Syy))
  d3 = 2*sum(diag(Sxx %*% Syy))
  d4 = (n1-1)/eta1*sum(diag(Sxx))^2
  d5 = (n2-1)/eta2*sum(diag(Syy))^2
  th = 4*(((n1+n2-2)/((n1-1)*(n2-1)))^2)*
    ((n1+n2-2)^2/((n1+n2)*(n1+n2-2-1))*
       (sum(diag(SsS %*% SsS))-(sum(diag(SsS)))^2/(n1+n2-2)))^2
  Sc = (d1+d2-d3-d4-d5)/sqrt(th)
  
  # Res = matrix(0,3,3)
  # Res[1, ] = c(ZCZt, CLX>cri, abs(Sc)>qnorm(1-alpha/2))
  # Res[3, ] = c(Tnm, CLX, abs(Sc))
  # CLX = CLX-(4*log(p)-log(log(p)))
  # Res[2, ] = c(sum(ts>=Tnm)/J,
  #              1 - exp(-exp(-CLX/2)/(sqrt(8*pi))),
  #              (1-pnorm(abs(Sc)))*2)
  #
  # rownames(Res) = c('decision', 'p-value', 'test statistic')
  # colnames(Res) = c('HDtest', 'CLX', 'Scott')
  # return(Res)
  
  # DNAME = deparse(substitute(X))
  # DNAME = paste(DNAME, "and", deparse(substitute(Y)))
  
  names(Tnm) = "Statistic"
  hd.res = list(statistics = Tnm, p.value = sum(ts>=Tnm)/J, alternative = "two.sided",
                method = "Two-Sample HD test", data.name = DNAME)
  class(hd.res) = "htest"
  
  names(CLX) = "Statistic"
  CLX.rev = CLX-(4*log(p)-log(log(p)))
  clx.p = 1 - exp(-exp(-CLX.rev/2)/(sqrt(8*pi)))
  clx.res = list(statistics = CLX, p.value = clx.p, alternative = "two.sided",
                 method = "Two-Sample CLX test", data.name = DNAME)
  class(clx.res) = "htest"
  
  names(Sc) = "Statistic"
  sc.p = (1-pnorm(abs(Sc)))*2
  sc.res = list(statistics = abs(Sc), p.value = sc.p, alternative = "two.sided",
                method = "Two-Sample Scott test", data.name = DNAME)
  class(sc.res) = "htest"
  
  res = list(HD = hd.res, CLX = clx.res, Scott = sc.res)
  return(res)
}

#' ' @name equalCovs
#' #' @aliases equalCovs
#' @title LC-test for equality of high dimensional covariances
#' @description Testing the equality of two high dimensional covariance matrices using the testing procedure by Li and Chen (2012).
#'
#' @param X The n x p data matrix from the sample 1
#' @param Y The n x p data matrix from the sample 2.
#' @param alpha The prescribed level of significance
#' @param DNAME Default input.
#'
#' @details Implementing testing procedure proposed by Li and Chen (2012) to test the equality of two sample high dimensional covariance matrices.
#'
#' @return Value of testing statistic, p-value, alternative hypothesis, and the name of testing procedure.
#'
#' @references J. Li and S. Chen (2012). Two sample tests for high-dimensional covariance matrices. Ann. Statist. 40, 908--940
#' @author Tong He
#' @export
#'


equalCovs <-function(X, Y, alpha, DNAME){
  # equalCovs <-function(sam1,sam2,size1,size2){
  ########################################################
  # obtain test statistic given in eqn (2.1) of the paper
  size1 = nrow(X)
  size2 = nrow(Y)
  A_mat <- X %*% t(X)
  out <- 0
  storage.mode(A_mat) <- "double"
  storage.mode(out) <- "double"
  nr <- as.integer(size1)
  
  # find A1
  #dyn.load("one1.dll")
  result1 <- .Fortran("code1", nr, A_mat, out=out, PACKAGE = "HDtest")
  A1 <- 2/(size1*(size1-1))*result1[[3]]
  
  # find A2
  #dyn.load("two2.dll")
  result2 <- .Fortran("code2", nr, A_mat, out=out, PACKAGE = "HDtest")
  A2 <- 4/(size1*(size1-1)*(size1-2))*result2[[3]]
  
  # find A3
  #dyn.load("three3.dll")
  result3 <- .Fortran("code3", nr, A_mat, out=out, PACKAGE = "HDtest")
  A3 <- 8/(size1*(size1-1)*(size1-2)*(size1-3))*result3[[3]]
  
  # obtain the statistic given by eqn (2.1) in our paper
  A_n1 <- A1-A2+A3
  
  # consider the sample 2
  
  B_mat <- Y %*% t(Y)
  out <- 0
  storage.mode(B_mat) <- "double"
  storage.mode(out) <- "double"
  nrr <- as.integer(size2)
  # find B1
  #dyn.load("one1.dll")
  result4 <- .Fortran("code1", nrr, B_mat, out=out, PACKAGE = "HDtest")
  B1 <- 2/(size2*(size2-1))*result4[[3]]
  
  # find B2
  #dyn.load("two2.dll")
  result5 <- .Fortran("code2", nrr, B_mat, out=out, PACKAGE = "HDtest")
  B2 <- 4/(size2*(size2-1)*(size2-2))*result5[[3]]
  
  # find B3
  #dyn.load("three3.dll")
  result6 <- .Fortran("code3", nrr, B_mat, out=out, PACKAGE = "HDtest")
  B3 <- 8/(size2*(size2-1)*(size2-2)*(size2-3))*result6[[3]]
  
  B_n2 <- B1-B2+B3
  
  ############################################################
  # obtain the test statistic given in eqn (2.2) of the paper
  ############################################################
  C_mat1 <- X %*% t(Y)
  C_mat2 <- Y %*% t(X)
  out <- 0
  storage.mode(C_mat1) <- "double"
  storage.mode(C_mat2) <- "double"
  storage.mode(out) <- "double"
  nrrr <- as.integer(size1)
  nl <- as.integer(size2)
  # find C1
  #dyn.load("four4.dll")
  result7 <- .Fortran("code4", nrrr, nl, C_mat1, out=out, PACKAGE = "HDtest")
  C1 <- -2/(size1*size2)*result7[[4]]
  
  # find C2
  #dyn.load("five5.dll")
  result8 <- .Fortran("code5", nl, nrrr, C_mat2, out=out, PACKAGE = "HDtest")
  C2 <- 4/(size1*size2*(size1-1))*result8[[4]]
  
  # find C3
  #dyn.load("five5.dll")
  result9 <- .Fortran("code5", nrrr, nl, C_mat1, out=out, PACKAGE = "HDtest")
  C3 <- 4/(size1*size2*(size2-1))*result9[[4]]
  
  # find C4
  #dyn.load("six6.dll")
  result10 <- .Fortran("code6", nrrr, nl, C_mat1, out=out, PACKAGE = "HDtest")
  C4 <- -4/(size1*size2*(size1-1)*(size2-1))*result10[[4]]
  
  # test statistic given by eqn (2.2) of the paper
  C_n <- C1+C2+C3+C4
  
  # the estimator
  T_n <- A_n1+B_n2+C_n
  
  # the standard deviation
  Sd_prime <- 2*(1/size1+1/size2)*((size1/(size1+size2))*A_n1+(size2/(size1+size2))*B_n2)
  
  test_stat <- T_n/Sd_prime
  pvalue <- 1-pnorm(test_stat)
  decision <- as.numeric(pvalue < alpha)
  # test <- matrix(0, 3, 1)
  # test[,1] <- c(decision, pvalue, test_stat)
  # colnames(test) = "LC"
  # rownames(test) = c('decision', 'p-value', 'test statistic')
  # return(test)
  # DNAME = deparse(substitute(X))
  # DNAME = paste(DNAME, "and", deparse(substitute(Y)))
  
  names(test_stat) = "Statistic"
  res = list(statistics = test_stat, p.value = pvalue, alternative = "two.sided",
             method = "Two-Sample LC test", data.name = DNAME)
  class(res) = "htest"
  
  return(res)
}
#### create neuropeptide expression dataframe ####
### extract neuropeptide expression and orig.idents from neurons
## create expression dataframe of neuropeptides
mouse.snseq.combined.sct.neurons.np.expression = mouse.snseq.combined.sct.neurons@assays$SCT@data %>% 
  as.data.frame() %>% 
  rownames_to_column('gene') %>% 
  mutate(gene = toupper(gene)) %>%
  filter(gene %in% neuropeptides.genes) %>% 
  column_to_rownames('gene') %>% 
  t() %>% 
  as.data.frame()

## create counts of presence absence
# use reads above 2 (in this case log(2) = 0.69)
mouse.snseq.combined.sct.neurons.np.expression.counts = mouse.snseq.combined.sct.neurons.np.expression %>% 
  mutate(across(where(is.numeric), 
                function(x) ifelse(x < .68, 0, x))) %>% 
  mutate(across(where(is.numeric), 
                function(x) ifelse(x >= .68, 1, x))) 

# create counts total matrix 
mouse.snseq.combined.sct.neurons.np.expression.counts.total = mouse.snseq.combined.sct.neurons.np.expression.counts %>% 
  colSums() %>% 
  as.data.frame() %>% 
  dplyr::rename('Counts' = ".") %>% 
  rownames_to_column('gene')

## graph histogram of neuropeptides
mouse.snseq.combined.sct.neurons.np.expression.counts.total %>%
  ggplot(aes(Counts)) +
  geom_histogram(binwidth = 10) +
  theme_bw()
ggsave('./neurons/neuropeptides/comparison/histogram all neuropeptides.png',
       height = 10,
       width = 10)

### add orig.ident information
mouse.snseq.combined.sct.neurons.np.expression.sample = mouse.snseq.combined.sct.neurons.np.expression %>% 
  rownames_to_column('Cell.id') %>% 
  full_join(mouse.snseq.combined.sct.neurons@meta.data %>% 
              rownames_to_column('Cell.id') %>% 
              dplyr::select(orig.ident,
                            Cell.id))
### create matrix for each orig.ident
##male
#dom
mouse.snseq.combined.sct.neurons.np.expression.male.dom = mouse.snseq.combined.sct.neurons.np.expression.sample %>% 
  filter(orig.ident == 'Male.Dom') %>% 
  dplyr::select(-c(orig.ident,
                   Cell.id))
#sub
mouse.snseq.combined.sct.neurons.np.expression.male.sub = mouse.snseq.combined.sct.neurons.np.expression.sample %>% 
  filter(orig.ident == 'Male.Sub') %>% 
  dplyr::select(-c(orig.ident,
                   Cell.id))

##female
#dom
mouse.snseq.combined.sct.neurons.np.expression.female.dom = mouse.snseq.combined.sct.neurons.np.expression.sample %>% 
  filter(orig.ident == 'Female.Dom') %>% 
  dplyr::select(-c(orig.ident,
                   Cell.id))
#sub
mouse.snseq.combined.sct.neurons.np.expression.female.sub = mouse.snseq.combined.sct.neurons.np.expression.sample %>% 
  filter(orig.ident == 'Female.Sub') %>% 
  dplyr::select(-c(orig.ident,
                   Cell.id))

### create counts of presence absence for each sample
# use reads above 2 (in this case log(2) = 0.69)
## male
#dom
mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts = mouse.snseq.combined.sct.neurons.np.expression.male.dom %>% 
  mutate(across(where(is.numeric), 
                function(x) ifelse(x < .68, 0, x))) %>% 
  mutate(across(where(is.numeric), 
                function(x) ifelse(x >= .68, 1, x))) 
#sub
mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts = mouse.snseq.combined.sct.neurons.np.expression.male.sub %>% 
  mutate(across(where(is.numeric), 
                function(x) ifelse(x < .68, 0, x))) %>% 
  mutate(across(where(is.numeric), 
                function(x) ifelse(x >= .68, 1, x))) 
## female
#dom
mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts = mouse.snseq.combined.sct.neurons.np.expression.female.dom %>% 
  mutate(across(where(is.numeric), 
                function(x) ifelse(x < .68, 0, x))) %>% 
  mutate(across(where(is.numeric), 
                function(x) ifelse(x >= .68, 1, x))) 
## male
#sub
mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts = mouse.snseq.combined.sct.neurons.np.expression.female.sub %>% 
  mutate(across(where(is.numeric), 
                function(x) ifelse(x < .68, 0, x))) %>% 
  mutate(across(where(is.numeric), 
                function(x) ifelse(x >= .68, 1, x))) 

### create counts total matrix for each sample
##male
#dom
mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.total = mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts %>% 
  colSums() %>% 
  as.data.frame() %>% 
  dplyr::rename('Counts' = ".") %>% 
  rownames_to_column('gene') %>% 
  mutate(orig.ident = 'Male.Dom')
#sub
mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.total = mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts %>% 
  colSums() %>% 
  as.data.frame() %>% 
  dplyr::rename('Counts' = ".") %>% 
  rownames_to_column('gene') %>% 
  mutate(orig.ident = 'Male.Sub')
##female
#dom
mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.total = mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts %>% 
  colSums() %>% 
  as.data.frame() %>% 
  dplyr::rename('Counts' = ".") %>% 
  rownames_to_column('gene') %>% 
  mutate(orig.ident = 'Female.Dom')
#sub
mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.total = mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts %>% 
  colSums() %>% 
  as.data.frame() %>% 
  dplyr::rename('Counts' = ".") %>% 
  rownames_to_column('gene') %>% 
  mutate(orig.ident = 'Female.Sub')

### combine dataframes together
mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total = rbind(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.total,
                                                                            mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.total) %>% 
  rbind(mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.total) %>% 
  rbind(mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.total)

## create neuroppeptide counts dataframe
neuropeptides.per.neuron.df = data.frame(NP.count = mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts %>% 
                                           rowSums(),
                                         orig.ident = 'Male.Dom',
                                         neuron.count = nrow(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts)) %>% 
  rbind(data.frame(NP.count = mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts %>% 
                     rowSums(),
                   orig.ident = 'Male.Sub',
                   neuron.count = nrow(mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts))) %>% 
  rbind(data.frame(NP.count = mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts %>% 
                     rowSums(),
                   orig.ident = 'Female.Dom',
                   neuron.count = nrow(mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts))) %>% 
  rbind(data.frame(NP.count = mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts %>% 
                     rowSums(),
                   orig.ident = 'Female.Sub',
                   neuron.count = nrow(mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts)))

#### create dataframe per genotype
### add orig.ident information
mouse.snseq.combined.sct.neurons.np.expression.genotype = mouse.snseq.combined.sct.neurons.np.expression %>% 
  rownames_to_column('Cell.id') %>% 
  full_join(mouse.snseq.combined.sct.neurons@meta.data %>% 
              rownames_to_column('Cell.id') %>% 
              dplyr::select(orig.ident,
                            Cell.id, 
                            Genotype))

### create matrix for each orig.ident
mouse.snseq.combined.sct.neurons.np.expression.genotype.mat = mouse.snseq.combined.sct.neurons.np.expression.genotype %>% 
  column_to_rownames('Cell.id') %>% 
  dplyr::select(-c(orig.ident,
                   Genotype)) 

### create counts of presence absence for each sample
# use reads above 2 (in this case log(2) = 0.69)
mouse.snseq.combined.sct.neurons.np.expression.genotype.mat = mouse.snseq.combined.sct.neurons.np.expression.genotype.mat %>% 
  mutate(across(where(is.numeric), 
                function(x) ifelse(x < .68, 0, x))) %>% 
  mutate(across(where(is.numeric), 
                function(x) ifelse(x >= .68, 1, x))) 

### count neuropeptides per cell
## include sample info and genotype data
## use cell.id to combine count data with metadata
neuropeptides.per.neuron.df.geno = mouse.snseq.combined.sct.neurons.np.expression.genotype.mat %>% 
  rowSums() %>% 
  as.data.frame() %>% 
  rename('NP.count' = '.') %>% 
  rownames_to_column('Cell.id') %>% 
  left_join(mouse.snseq.combined.sct.neurons@meta.data %>% 
              rownames_to_column('Cell.id') %>% 
              dplyr::select(orig.ident,
                            Cell.id, 
                            Genotype)) %>% 
  mutate(Genotype.id = paste0(orig.ident,
                              '_',
                              Genotype)) %>% 
  group_by(Genotype.id) %>% 
  mutate(neuron.count = n())

## create neuropeptides per nuclei per count matrix
neuropeptides.per.neuron.df.geno.count = mouse.snseq.combined.sct.neurons.np.expression.genotype.mat %>% 
  as.data.frame() %>% 
  rownames_to_column('Cell.id') %>% 
  left_join(mouse.snseq.combined.sct.neurons@meta.data %>% 
              rownames_to_column('Cell.id') %>% 
              dplyr::select(orig.ident,
                            Cell.id, 
                            Genotype)) %>% 
  mutate(Genotype.id = paste0(orig.ident,
                              '_',
                              Genotype)) %>% 
  dplyr::select(-c(Cell.id)) %>% 
  group_by(Genotype.id) %>% 
  mutate(keep = 1,
         total.count = sum(keep)) %>% 
  dplyr::select(-c(keep)) %>% 
  ungroup() %>% 
  pivot_longer(cols = -c(orig.ident,
                         Genotype,
                         Genotype.id,
                         total.count),
               names_to = 'neuropeptide',
               values_to = 'presence') %>% 
  group_by(orig.ident,
           Genotype,
           Genotype.id,
           neuropeptide,
           total.count) %>% 
  summarise(neuropeptide.nuclei.count = sum(presence)) %>% 
  ungroup() %>% 
  separate_wider_delim(orig.ident,
                       delim = '.',
                       names = c('Sex',
                                 'Status'),
                       cols_remove = F) %>% 
  mutate(percent = 100*(neuropeptide.nuclei.count/total.count))

## Get the number of AVP neurons that express OXT for each genotype
AVP.OXT.overlap.per.neuron.df.geno.count = mouse.snseq.combined.sct.neurons.np.expression.genotype.mat %>% 
  as.data.frame() %>% 
  rownames_to_column('Cell.id') %>% 
  left_join(mouse.snseq.combined.sct.neurons@meta.data %>% 
              rownames_to_column('Cell.id') %>% 
              dplyr::select(orig.ident,
                            Cell.id, 
                            Genotype)) %>% 
  mutate(Genotype.id = paste0(orig.ident,
                              '_',
                              Genotype)) %>% 
  dplyr::select(c(AVP,
                  OXT,
                  orig.ident,
                  Genotype.id,
                  Genotype)) %>% 
  filter(AVP == 1) %>% 
  group_by(orig.ident,
           Genotype.id,
           Genotype,
           AVP, 
           OXT) %>% 
  summarise(total.count = n()) %>% 
  ungroup() %>% 
  mutate(AVP.OXT = ifelse(OXT == 1,
                          'AVP.OXT',
                          'AVP')) %>% 
  pivot_wider(id_cols = c(orig.ident,
                          Genotype.id,
                          Genotype),
              names_from = AVP.OXT,
              values_from = total.count) %>% 
  mutate(total.avp = AVP + AVP.OXT,
         percent = 100*AVP.OXT/total.avp)
  
#### neuropeptide count statistics ####
### compare number of neuropeptide expressing cells across samples
### GLM binomial
library(multcomp)
library(emmeans)

### run glm on every cluster
## use with proportion data
# create empty data frame
neuropeptide.genes.glm = data.frame(matrix(ncol = 7, nrow = 0))

#provide column names
colnames(neuropeptide.genes.glm) <- c("contrast",
                                "Estimate",
                                "Std.error",
                                "z.value",
                                "adj.pvalue",
                                "z.ratio",
                                "Genes")
## loop through each cluster
for (i in unique(neuropeptides.per.neuron.df.geno.count$neuropeptide)) {
  ## run interaction binomial GLM on sex and status
  tmp = glm(cbind(neuropeptide.nuclei.count, Others) ~ Sex*Status, 
            data = neuropeptides.per.neuron.df.geno.count %>% 
              filter(neuropeptide == i) %>% 
              mutate(Others = total.count - neuropeptide.nuclei.count,
                     Status = as.factor(Status),
                     Sex = as.factor(Sex)), 
            family = binomial)
  # multivariate t distribution to correct for multiple testing
  tmp.res = summary(glht(tmp))
  
  # save results
  tmp.res.df = data.frame(Estimate = tmp.res$test$coefficients,
                          Std.error = tmp.res$test$sigma,
                          z.value = tmp.res$test$tstat,
                          adj.pvalue = tmp.res$test$pvalues,
                          z.ratio = NA) %>% 
    rownames_to_column('contrast') %>% 
    mutate(Genes = i)
  
  
  ## run all pairwise comparison
  # Tukey needed for all pairwise comparisons
  tmp2 = glm(cbind(neuropeptide.nuclei.count, Others) ~ orig.ident, 
             data = neuropeptides.per.neuron.df.geno.count %>% 
               filter(neuropeptide == i) %>% 
               mutate(Others = total.count - neuropeptide.nuclei.count,
                      Status = as.factor(Status),
                      Sex = as.factor(Sex)), 
             family = binomial)
  
  # use emmeans to get pairwise differences
  emm = emmeans(tmp2,
                ~ "orig.ident")
  emm.res = pairs(emm)
  
  
  # save results
  emm.res.df = data.frame(Estimate = summary(emm.res)$estimate,
                          Std.error = summary(emm.res)$SE,
                          z.ratio = summary(emm.res)$z.ratio,
                          adj.pvalue = summary(emm.res)$p.value,
                          contrast = summary(emm.res)$contrast,
                          z.value = NA) %>%
    mutate(Genes = i)
  
  ## combine in data frame
  neuropeptide.genes.glm = neuropeptide.genes.glm %>% 
    rbind(tmp.res.df) %>% 
    rbind(emm.res.df)
}


## FDR correction for all comparisons
neuropeptide.genes.glm.fdr = neuropeptide.genes.glm %>%
  filter(is.na(z.ratio)) %>%
  filter(contrast != "(Intercept)") %>%
  group_by(Genes) %>% 
  mutate(p.adjust.fdr = p.adjust(adj.pvalue,
                                 method = 'fdr',
                                 n = 68))

# combine with data frame
neuropeptide.genes.glm = neuropeptide.genes.glm %>%
  left_join(neuropeptide.genes.glm.fdr)



## create rounded p.value to make it easier to read
neuropeptide.genes.glm = neuropeptide.genes.glm %>%
  mutate(adj.pvalue.round = ifelse(is.na(p.adjust.fdr),
                                   round(adj.pvalue, digits = 4),
                                   round(p.adjust.fdr, digits = 4)))

## save glm table
write_csv(neuropeptide.genes.glm,
          file = 'neurons/neuropeptides/comparison/neuropeptide.genes.glm.csv')

### graph
## get average percentage of neuropeptide nuclei state
neuropeptides.per.neuron.df.geno.count.percent = neuropeptides.per.neuron.df.geno.count %>% 
  group_by(Sex,
           Status,
           neuropeptide) %>% 
  summarise(percent.avg = mean(percent))

## males
# get list of significant genes for males
neuropeptide.genes.glm.male.genes = neuropeptide.genes.glm %>% 
  filter(contrast == 'Male.Dom - Male.Sub') %>% 
  filter(adj.pvalue.round <= 0.05) %>% 
  mutate(Male.direction = ifelse(Estimate > 0,
                                 "Male.Dom.Bias",
                                 "Male.Sub.Bias")) %>% 
  dplyr::select(Male.direction,
                Genes) %>% 
  dplyr::rename(neuropeptide = Genes)
  
# label with significace 
neuropeptides.per.neuron.df.geno.count.percent %>% 
  filter(Sex == 'Male') %>% 
  pivot_wider(id_cols = c('neuropeptide'),
              names_from = 'Status',
              values_from = 'percent.avg') %>% 
  full_join(neuropeptide.genes.glm.male.genes) %>% 
  mutate(label = ifelse(is.na(Male.direction),
                                 NA,
                                 neuropeptide),
         Male.direction = ifelse(is.na(Male.direction),
                                 'no bias',
                                 Male.direction)) %>% 
  ggplot(aes(x = Sub,
             y = Dom,
             label = label)) +
  # geom_rect(mapping=aes(xmin=0, xmax=0.5, ymin=0, ymax=0.5), color="grey", fill = 'white', linetype = 'dashed') +
  geom_abline(slope = 1,
              intercept = 0) +
  geom_point(aes(color = Male.direction),
             size = 3) +
  geom_text_repel(aes(
    # alpha = Male.color,
                      size = 15),
                  size = 3) +
  theme_classic() +
  # scale_x_continuous(trans='log10') +
  # scale_y_continuous(trans='log10') +
  scale_color_manual(values = c("#0077CC",
                                "#0095FF",
                                "grey"),
                     name = "Status Bias") +
  # scale_alpha_discrete(guide = "none",
  #                      range = c(1, 0.50)) +
  scale_size(guide = 'none')+
  theme(legend.position = c(0.8, 0.2))+ 
  theme(text = element_text(size = 15)) +
  xlab('Subordinate Male neuropeptide proportion (%)') +
  ylab('Dominant Male neuropeptide proportion (%)')+
  ggtitle('Male Neuropeptide Cell Proportion') +
  xlim(0,100)+
  ylim(0,100)
ggsave('./neurons/neuropeptides/comparison/neuropeptides count scaled males paper glm.png',
       height = 5.25,
       width = 5.25)


## males
# get list of significant genes for males
neuropeptide.genes.glm.female.genes = neuropeptide.genes.glm %>% 
  filter(contrast == 'Female.Dom - Female.Sub') %>% 
  filter(adj.pvalue.round <= 0.01) %>% 
  mutate(Female.direction = ifelse(Estimate > 0,
                                 "Female.Dom.Bias",
                                 "Female.Sub.Bias")) %>% 
  dplyr::select(Female.direction,
                Genes) %>% 
  dplyr::rename(neuropeptide = Genes)

# label with significace 
neuropeptides.per.neuron.df.geno.count.percent %>% 
  filter(Sex == 'Female') %>% 
  pivot_wider(id_cols = c('neuropeptide'),
              names_from = 'Status',
              values_from = 'percent.avg') %>% 
  full_join(neuropeptide.genes.glm.female.genes) %>% 
  mutate(label = ifelse(is.na(Female.direction),
                        NA,
                        neuropeptide),
         Female.direction = ifelse(is.na(Female.direction),
                                 'no bias',
                                 Female.direction)) %>% 
  ggplot(aes(x = Sub,
             y = Dom,
             label = label)) +
  # geom_rect(mapping=aes(xmin=0, xmax=0.5, ymin=0, ymax=0.5), color="grey", fill = 'white', linetype = 'dashed') +
  geom_abline(slope = 1,
              intercept = 0) +
  geom_point(aes(color = Female.direction),
             size = 3) +
  geom_text_repel(aes(
    # alpha = Male.color,
    size = 15),
    size = 3) +
  theme_classic() +
  # scale_x_continuous(trans='log10') +
  # scale_y_continuous(trans='log10') +
  scale_color_manual(values = c("#CC5500",
                                "#FF6A00",
                                "grey"),
                     name = "Status Bias") +
  # scale_alpha_discrete(guide = "none",
  #                      range = c(1, 0.50)) +
  scale_size(guide = 'none')+
  theme(legend.position = c(0.8, 0.2))+ 
  theme(text = element_text(size = 15)) +
  xlab('Subordinate Female neuropeptide proportion (%)') +
  ylab('Dominant Female neuropeptide proportion (%)')+
  ggtitle('Female Neuropeptide Cell Proportion') +
  xlim(0,100)+
  ylim(0,100)
ggsave('./neurons/neuropeptides/comparison/neuropeptides count scaled females paper glm.png',
       height = 5.25,
       width = 5.25)

### compare AVP and OXT 
library(ggthemes)
library(multcompView)

## anova
AVP.OXT.overlap.per.neuron.aov.state =  aov(percent ~ Sex*Status,
                                      data = AVP.OXT.overlap.per.neuron.df.geno.count %>% 
                                        separate_wider_delim(orig.ident,
                                                             delim = '.',
                                                             names = c('Sex',
                                                                       'Status')))

summary(AVP.OXT.overlap.per.neuron.aov.state)

# pairwise
AVP.OXT.overlap.per.neuron.aov =  aov(percent ~ orig.ident,
    data = AVP.OXT.overlap.per.neuron.df.geno.count )

summary(AVP.OXT.overlap.per.neuron.aov)

# Tukey's test
AVP.OXT.overlap.per.neuron.aov.tukey <- TukeyHSD(AVP.OXT.overlap.per.neuron.aov)

# compact letter display
AVP.OXT.overlap.per.neuron.cld <- multcompLetters4(AVP.OXT.overlap.per.neuron.aov, 
                        AVP.OXT.overlap.per.neuron.aov.tukey)

# table with factors and 3rd quantile
dt <- group_by(AVP.OXT.overlap.per.neuron.df.geno.count,
               orig.ident) %>%
  summarise(percent=mean(percent), 
            sd = sd(percent)) %>%
  arrange(desc(percent))

# extracting the compact letter display and adding to the Tk table
AVP.OXT.overlap.per.neuron.cld <- as.data.frame.list(AVP.OXT.overlap.per.neuron.cld$orig.ident)
dt$AVP.OXT.overlap.per.neuron.cld <- AVP.OXT.overlap.per.neuron.cld$Letters

## save statistical results
AVP.OXT.overlap.per.neuron.aov.df = broom::tidy(AVP.OXT.overlap.per.neuron.aov.state) %>% 
  full_join(broom::tidy(AVP.OXT.overlap.per.neuron.aov.tukey))

write_csv(AVP.OXT.overlap.per.neuron.aov.df,
          'neurons/neuropeptides/comparison/AVP.OXT.overlap.per.neuron.aov.df.csv')

## graph overlap
# add scale bar
AVP.OXT.overlap.per.neuron.df.geno.count %>% 
  ggplot(aes(x = reorder(orig.ident,
                         -percent),
             y=percent,
             fill = orig.ident)) +
  stat_summary(fun.y=mean, 
               geom="bar") +
  geom_point(size = 3) +
  geom_line() +
  geom_text(data = dt,
            aes(label = AVP.OXT.overlap.per.neuron.cld, 
                y = percent), 
            vjust = -2
            ) +
  theme_classic() +
  ylab('Percentage AVP neurons OXT+') +
  xlab('') + 
  scale_fill_manual(values = c("#CC5500",
                                "#FF6A00",
                                "#0077CC",
                                "#0095FF")) +
  theme(text = element_text(size = 20),
        legend.position = 'none') +
  ylim(0,100)
ggsave('./neurons/neuropeptides/Bar chart overlap AVP neurons expressing OXT color percent.png',
       height = 6,
       width = 10)

#### graph neuropeptides ####
# ## graph histogram of neuropeptides
mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total %>%
  ggplot(aes(Counts,
             fill = orig.ident)) +
  geom_histogram(binwidth = 10) +
  theme_bw()
ggsave('./neurons/neuropeptides/comparison/histogram samples neuropeptides.png',
       height = 10,
       width = 10)


## graph counts of neuropeptides
mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total %>%
  ggplot(aes(y = Counts,
             x = reorder(gene,
                          -Counts),
             color = orig.ident)) +
  geom_point() +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  xlab('')
ggsave('./neurons/neuropeptides/comparison/counts samples neuropeptides.png',
       height = 10,
       width = 10)

## create graph of count of genes present in cells by threshold number of cells
# create data frame
mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total.threshold = data.frame(np.genes = as.numeric(),
                                                                                           count.threshold = as.numeric())
for (i in seq(from=0, to=200, by =10)) {
  tmp = c(mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total %>% 
    filter(Counts >= i) %>% 
    pull(gene) %>% 
    unique() %>% 
    length(),
    i)
  mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total.threshold[nrow(mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total.threshold) + 1, ] = tmp
}
# graph data
mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total.threshold %>%
  ggplot(aes(y = np.genes,
             x = count.threshold)) +
  geom_point() +
  theme_bw() +
  ylim(0,80)
ggsave('./neurons/neuropeptides/comparison/gene counts above threshold samples neuropeptides.png',
       height = 10,
       width = 10)


### compare counts across social status
mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total.df =  mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total %>% 
  pivot_wider(names_from = orig.ident,
              values_from = Counts) %>% 
  ungroup() %>% 
    group_by(gene) %>% 
  mutate(Male.label = case_when(Male.Dom/Male.Sub > 1.5 & Male.Dom > 50 ~ gene,
                                Male.Sub/Male.Dom > 1.5 & Male.Sub > 50 ~ gene),
         Female.label = case_when(Female.Dom/Female.Sub > 1.5 & Female.Dom > 50  ~ gene,
                                  Female.Sub/Female.Dom > 1.5 & Female.Sub > 50  ~ gene)) %>% 
    ungroup() 
  

## scale by neuron count
# get counts to scale by
mouse.snseq.combined.sct.neurons@meta.data %>% select(orig.ident) %>% table( )
#Female.Dom Female.Sub   Male.Dom   Male.Sub 
# 5520       3042       3353       4138
mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total.df.scaled =  mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total %>% 
  mutate(Counts = case_when(orig.ident=='Male.Dom' ~ Counts,
                                   orig.ident=='Male.Sub' ~ Counts*3353/4138,
                                   orig.ident=='Female.Dom' ~ Counts*3042/5520,
                                   orig.ident=='Female.Sub' ~ Counts)) %>% 
  pivot_wider(names_from = orig.ident,
              values_from = Counts) %>% 
  ungroup() %>% 
  group_by(gene) %>% 
  mutate(Male.label = case_when(Male.Dom/Male.Sub > 1.5 & Male.Dom > 50 ~ gene,
                                Male.Sub/Male.Dom > 1.5 & Male.Sub > 50 ~ gene),
         Female.label = case_when(Female.Dom/Female.Sub > 1.5 & Female.Dom > 50  ~ gene,
                                  Female.Sub/Female.Dom > 1.5 & Female.Sub > 50  ~ gene)) %>% 
  ungroup() 


## graph neuron counts
#males
mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total.df %>%
  ggplot(aes(x = Male.Sub,
             y = Male.Dom,
             label = Male.label)) +
  geom_abline(slope = 1,
              intercept = 0) +
  geom_point() +
  geom_label_repel() +
  theme_classic() +
  scale_x_continuous(trans='log10') +
  scale_y_continuous(trans='log10')
ggsave('./neurons/neuropeptides/comparison/neuropeptides count males.png',
       height = 10,
       width = 10)
#females
mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total.df %>%
  ggplot(aes(x = Female.Sub,
             y = Female.Dom,
             label = Female.label)) +
  geom_abline(slope = 1,
              intercept = 0) +
  geom_point() +
  geom_label_repel() +
  theme_classic() +
  scale_x_continuous(trans='log10') +
  scale_y_continuous(trans='log10')
ggsave('./neurons/neuropeptides/comparison/neuropeptides count females.png',
       height = 10,
       width = 10)

## graph neuron counts scaled
#males
mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total.df.scaled %>%
  ggplot(aes(x = Male.Sub,
             y = Male.Dom,
             label = Male.label)) +
  geom_abline(slope = 1,
              intercept = 0) +
  geom_point() +
  geom_label_repel() +
  theme_classic() +
  scale_x_continuous(trans='log10') +
  scale_y_continuous(trans='log10')
ggsave('./neurons/neuropeptides/comparison/neuropeptides count scaled males.png',
       height = 10,
       width = 10)
#females
mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total.df.scaled %>%
  ggplot(aes(x = Female.Sub,
             y = Female.Dom,
             label = Female.label)) +
  geom_abline(slope = 1,
              intercept = 0) +
  geom_point() +
  geom_label_repel() +
  theme_classic() +
  scale_x_continuous(trans='log10') +
  scale_y_continuous(trans='log10')
ggsave('./neurons/neuropeptides/comparison/neuropeptides count scaled females.png',
       height = 10,
       width = 10)



#### graphs for poster
## graph neuron counts scaled
## get same labels
neuropeptides.poster.df = mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total.df.scaled %>% 
  mutate(label = case_when(!is.na(Male.label) ~ Male.label,
                           !is.na(Female.label) ~ Female.label
                           )) %>% 
  mutate(Male.color = ifelse(!is.na(Male.label),
                             '50% bias',
                             'no bias')) %>% 
  mutate(Female.color = ifelse(!is.na(Female.label),
                             '50% bias',
                             'no bias'))

#males
neuropeptides.poster.df %>%
  ggplot(aes(x = Male.Sub,
             y = Male.Dom,
             label = label)) +
  geom_rect(mapping=aes(xmin=0, xmax=50, ymin=0, ymax=50), color="grey", fill = 'white', linetype = 'dashed') +
  geom_abline(slope = 1,
              intercept = 0) +
  geom_point(aes(color = Male.color),
             size = 3) +
  geom_label_repel(aes(alpha = Male.color,
                       size = 15),
                   size = 3) +
  theme_classic() +
  scale_x_continuous(trans='log10') +
  scale_y_continuous(trans='log10') +
  scale_color_manual(values = c('black',
                                'grey'),
                     name = "Status Bias") +
  scale_alpha_discrete(guide = "none",
                       range = c(1, 0.50)) +
  scale_size(guide = 'none')+
  theme(legend.position = c(0.8, 0.2))+ 
  theme(text = element_text(size = 15)) +
  xlab('Subordinate Male') +
  ylab('Dominant Male')+
  ggtitle('Male Neuropeptide Cell Count')
ggsave('./neurons/neuropeptides/comparison/neuropeptides count scaled males.pdf',
       height = 5.25,
       width = 5.25)

#females
neuropeptides.poster.df %>% 
  ggplot(aes(x = Female.Sub,
             y = Female.Dom,
             label = label)) +
  geom_rect(mapping=aes(xmin=0, xmax=50, ymin=0, ymax=50), color="grey", fill = 'white', linetype = 'dashed') +
  geom_abline(slope = 1,
              intercept = 0) +
  geom_point(aes(color = Female.color),
             size = 3) +
  geom_label_repel(aes(alpha = Female.color,
                       size = 15),
                   size = 3) +
  theme_classic() +
  scale_x_continuous(trans='log10') +
  scale_y_continuous(trans='log10') +
  scale_color_manual(values = c('black',
                                'grey'),
                     name = "Status Bias") +
  scale_alpha_discrete(guide = "none",
                       range = c(1, 0.50)) +
  scale_size(guide = 'none')+
  theme(legend.position = c(0.8, 0.2))+ 
  theme(text = element_text(size = 15)) +
  xlab('Subordinate Female') +
  ylab('Dominant Female')+
  ggtitle('Female Neuropeptide Cell Count')
ggsave('./neurons/neuropeptides/comparison/neuropeptides count scaled females.pdf',
       height = 5.25,
       width = 5.25)


## remove labels
# add color
# c("#CC5500",
#   +                                 "#FF6A00",
#   +                                 "#0077CC",
#   +                                 "#0095FF")
#males
neuropeptides.poster.df %>% 
  mutate(Male.direction = case_when(!is.na(Male.label) & Male.Dom > Male.Sub ~ "50% Male.Dom.bias",
                                    !is.na(Male.label) & Male.Dom < Male.Sub ~ "50% Male.Sub.bias",
                                    TRUE ~ 'no bias')) %>% 
  ggplot(aes(x = Male.Sub,
             y = Male.Dom,
             label = label)) +
  geom_rect(mapping=aes(xmin=0, xmax=50, ymin=0, ymax=50), color="grey", fill = 'white', linetype = 'dashed') +
  geom_abline(slope = 1,
              intercept = 0) +
  geom_point(aes(color = Male.direction),
             size = 3) +
  geom_text_repel(aes(alpha = Male.color,
                       size = 15),
                   size = 3) +
  theme_classic() +
  scale_x_continuous(trans='log10') +
  scale_y_continuous(trans='log10') +
  scale_color_manual(values = c("#0077CC",
                                "#0095FF",
                                "grey"),
                     name = "Status Bias") +
  scale_alpha_discrete(guide = "none",
                       range = c(1, 0.50)) +
  scale_size(guide = 'none')+
  theme(legend.position = c(0.8, 0.2))+ 
  theme(text = element_text(size = 15)) +
  xlab('Subordinate Male') +
  ylab('Dominant Male')+
  ggtitle('Male Neuropeptide Cell Count')
ggsave('./neurons/neuropeptides/comparison/neuropeptides count scaled males paper.pdf',
       height = 5.25,
       width = 5.25)

#females
neuropeptides.poster.df %>% 
  mutate(Female.direction = case_when(!is.na(Female.label) & Female.Dom > Female.Sub ~ "50% Female.Dom.bias",
                                    !is.na(Female.label) & Female.Dom < Female.Sub ~ "50% Female.Sub.bias",
                                    TRUE ~ 'no bias')) %>% 
  ggplot(aes(x = Female.Sub,
             y = Female.Dom,
             label = label)) +
  geom_rect(mapping=aes(xmin=0, xmax=50, ymin=0, ymax=50), color="grey", fill = 'white', linetype = 'dashed') +
  geom_abline(slope = 1,
              intercept = 0) +
  geom_point(aes(color = Female.direction),
             size = 3) +
  geom_text_repel(aes(alpha = Female.color,
                       size = 15),
                   size = 3) +
  theme_classic() +
  scale_x_continuous(trans='log10') +
  scale_y_continuous(trans='log10') +
  scale_color_manual(values = c("#CC5500",
                                "#FF6A00",
                                "grey"),
                     name = "Status Bias") +
  scale_alpha_discrete(guide = "none",
                       range = c(1, 0.50)) +
  scale_size(guide = 'none')+
  theme(legend.position = c(0.8, 0.2))+ 
  theme(text = element_text(size = 15)) +
  xlab('Subordinate Female') +
  ylab('Dominant Female')+
  ggtitle('Female Neuropeptide Cell Count')
ggsave('./neurons/neuropeptides/comparison/neuropeptides count scaled females paper.pdf',
       height = 5.25,
       width = 5.25)


### graph histogram of neuropeptides per neuron

## graph histogram
neuropeptides.per.neuron.df %>%
  table() %>% 
  as.data.frame() %>% 
  filter(Freq != 0) %>% 
  ggplot(aes(x = NP.count,
             y = Freq,
             group = orig.ident,
             color = orig.ident,
             fill = orig.ident)) +
  geom_point() +
  geom_line() +
  theme_classic()
ggsave('./neurons/neuropeptides/comparison/neuropeptides per neuron.png',
       height = 10,
       width = 10)

# percent
neuropeptides.per.neuron.df %>% 
  table() %>%
  as.data.frame() %>% 
  mutate(Percent = 100*Freq/as.integer(as.character(neuron.count))) %>% 
  filter(Freq != 0) %>%
  ggplot(aes(x = NP.count,
             y = Percent,
             group = orig.ident,
             color = orig.ident,
             fill = orig.ident)) +
  geom_point(size = 3) +
  geom_line() +
  theme_classic() + 
  scale_color_manual(values = c("#CC5500",
                                "#FF6A00",
                                "#0077CC",
                                "#0095FF"))
ggsave('./neurons/neuropeptides/comparison/neuropeptides per neuron percent.png',
       height = 10,
       width = 10)

# create cumulative freq plot
neuropeptides.per.neuron.df %>% 
  table() %>%
  as.data.frame() %>% 
  mutate(Percent = 100*Freq/as.integer(as.character(neuron.count))) %>% 
  filter(Freq != 0) %>% 
  select(NP.count,
         orig.ident,
         Percent) %>% 
  group_by(orig.ident) %>% 
  mutate(Cum.Percent = cumsum(Percent)) %>%
  ggplot(aes(x = NP.count,
             y = Cum.Percent,
             group = orig.ident,
             color = orig.ident,
             fill = orig.ident)) +
  geom_point(size = 3) +
  geom_line() +
  theme_classic() + 
  scale_color_manual(values = c("#CC5500",
                                "#FF6A00",
                                "#0077CC",
                                "#0095FF"))
ggsave('./neurons/neuropeptides/comparison/neuropeptides per neuron percent cumulative.png',
       height = 10,
       width = 10)

## genotype
# percent
neuropeptides.per.neuron.df %>%
  table() %>%
  as.data.frame() %>% 
  mutate(Percent = 100*Freq/as.integer(as.character(neuron.count))) %>% 
  filter(Freq != 0) %>% 
  ggplot() +
  geom_point(aes(x = NP.count,
                 y = Percent,
                 group = orig.ident,
                 color = orig.ident,
                 fill = orig.ident),
             size = 3,
             shape = 3) +
  geom_line(aes(x = NP.count,
                y = Percent,
                group = orig.ident,
                color = orig.ident)) +
  geom_point(data = neuropeptides.per.neuron.df.geno %>%
               dplyr::select(NP.count,
                             orig.ident,
                             neuron.count,
                             Genotype) %>% 
               table() %>%
               as.data.frame() %>% 
               mutate(Percent = 100*Freq/as.integer(as.character(neuron.count))) %>% 
               filter(Freq != 0),
             aes(x = NP.count,
                 y = Percent,
                 color = orig.ident,
                 fill = orig.ident),
             size = 3) +
  geom_line(data = neuropeptides.per.neuron.df.geno %>%
              dplyr::select(NP.count,
                            orig.ident,
                            neuron.count,
                            Genotype) %>% 
              table() %>%
              as.data.frame() %>% 
              mutate(Percent = 100*Freq/as.integer(as.character(neuron.count))) %>% 
              filter(Freq != 0),
            aes(x = NP.count,
                y = Percent,
                color = orig.ident)) +
  theme_classic() + 
  scale_color_manual(values = c("#CC5500",
                                "#FF6A00",
                                "#0077CC",
                                "#0095FF"))
ggsave('./neurons/neuropeptides/comparison/neuropeptides per neuron percent genotype.png',
       height = 10,
       width = 10)

# create cumulative freq plot
neuropeptides.per.neuron.df %>%
  table() %>%
  as.data.frame() %>% 
  mutate(Percent = 100*Freq/as.integer(as.character(neuron.count))) %>% 
  filter(Freq != 0) %>% 
  group_by(orig.ident) %>% 
  mutate(Cum.Percent = cumsum(Percent)) %>%
  ggplot() +
  geom_point(aes(x = NP.count,
                 y = Cum.Percent,
                 group = orig.ident,
                 color = orig.ident,
                 fill = orig.ident),
             size = 3,
             shape = 3) +
  geom_line(aes(x = NP.count,
                y = Cum.Percent,
                group = orig.ident,
                color = orig.ident)) +
  geom_point(data = neuropeptides.per.neuron.df.geno %>%
               dplyr::select(NP.count,
                             orig.ident,
                             neuron.count,
                             Genotype) %>% 
               table() %>%
               as.data.frame() %>% 
               mutate(Percent = 100*Freq/as.integer(as.character(neuron.count))) %>% 
               filter(Freq != 0) %>% 
               group_by(Genotype.id) %>% 
               mutate(Cum.Percent = cumsum(Percent)),
             aes(x = NP.count,
                 y = Cum.Percent,
                 color = orig.ident,
                 fill = orig.ident),
             size = 3) +
  geom_line(data = neuropeptides.per.neuron.df.geno %>%
              dplyr::select(NP.count,
                            orig.ident,
                            neuron.count,
                            Genotype) %>% 
              table() %>%
              as.data.frame() %>% 
              mutate(Percent = 100*Freq/as.integer(as.character(neuron.count))) %>% 
              filter(Freq != 0) %>% 
              group_by(Genotype.id) %>% 
              mutate(Cum.Percent = cumsum(Percent)),
            aes(x = NP.count,
                y = Cum.Percent,
                color = orig.ident)) +
  theme_classic() + 
  scale_color_manual(values = c("#CC5500",
                                "#FF6A00",
                                "#0077CC",
                                "#0095FF"))
ggsave('./neurons/neuropeptides/comparison/neuropeptides per neuron percent cumulative genotype.png',
       height = 10,
       width = 10)

# create cumulative freq plot
# just dom males
neuropeptides.per.neuron.df %>%
  table() %>%
  as.data.frame() %>% 
  mutate(Percent = 100*Freq/as.integer(as.character(neuron.count))) %>% 
  filter(Freq != 0) %>% 
  group_by(orig.ident) %>% 
  mutate(Cum.Percent = cumsum(Percent)) %>%
  filter(orig.ident == 'Male.Dom') %>% 
  ggplot() +
  geom_point(aes(x = NP.count,
                 y = Cum.Percent,
                 group = orig.ident,
                 color = orig.ident,
                 fill = orig.ident),
             size = 3,
             shape = 3) +
  geom_line(aes(x = NP.count,
                y = Cum.Percent,
                group = orig.ident,
                color = orig.ident)) +
  geom_point(data = neuropeptides.per.neuron.df.geno %>%
               dplyr::select(NP.count,
                             orig.ident,
                             neuron.count,
                             Genotype) %>% 
               table() %>%
               as.data.frame() %>% 
               mutate(Percent = 100*Freq/as.integer(as.character(neuron.count))) %>% 
               filter(Freq != 0) %>% 
               group_by(Genotype.id) %>% 
               mutate(Cum.Percent = cumsum(Percent)) %>%
               filter(orig.ident == 'Male.Dom'),
             aes(x = NP.count,
                 y = Cum.Percent,
                 color = orig.ident,
                 fill = orig.ident),
             size = 3) +
  geom_line(data = neuropeptides.per.neuron.df.geno %>%
              dplyr::select(NP.count,
                            orig.ident,
                            neuron.count,
                            Genotype) %>% 
              table() %>%
              as.data.frame() %>% 
              mutate(Percent = 100*Freq/as.integer(as.character(neuron.count))) %>% 
              filter(Freq != 0) %>% 
              group_by(Genotype.id) %>% 
              mutate(Cum.Percent = cumsum(Percent)) %>%
              filter(orig.ident == 'Male.Dom'),
            aes(x = NP.count,
                y = Cum.Percent,
                color = orig.ident)) +
  theme_classic() + 
  scale_color_manual(values = c("#CC5500",
                                "#FF6A00",
                                "#0077CC",
                                "#0095FF")) +
  ylab('Cumulative percentage') +
  xlab('Neuropeptides per neuron') 
ggsave('./neurons/neuropeptides/comparison/neuropeptides per neuron percent cumulative genotype dom male.png',
       height = 10,
       width = 10)

#### graph networks all ####
### create network dataframe 
# remove low expressing genes
# remove low expressing cells
mouse.snseq.combined.sct.neurons.np.expression.filter = mouse.snseq.combined.sct.neurons.np.expression %>% 
  remove_nonexp(method = "percentage",
                min_exp = 0.68,
                min_percentage_samples = .05)  %>% 
  t() %>% 
  remove_nonexp(method = "percentage",
                min_exp = 0.68,
                min_percentage_samples = .1) 


ncol(mouse.snseq.combined.sct.neurons.np.expression.filter)
# 13910 cells out of 16053
nrow(mouse.snseq.combined.sct.neurons.np.expression.filter)
# 18 genes out of 71


## create graph object
mouse.snseq.combined.sct.neurons.np.expression.filter.g <- graph.adjacency(
  as.matrix(as.dist(cor(t(mouse.snseq.combined.sct.neurons.np.expression.filter), method="pearson"))),
  mode="undirected",
  weighted=TRUE,
  diag=FALSE
)

# Simplfy the adjacency object
mouse.snseq.combined.sct.neurons.np.expression.filter.g <- igraph::simplify(mouse.snseq.combined.sct.neurons.np.expression.filter.g, remove.multiple=TRUE, remove.loops=TRUE)

# Colour negative correlation edges as blue
E(mouse.snseq.combined.sct.neurons.np.expression.filter.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.g)$weight<0)]$color <- "darkblue"

# Colour positive correlation edges as red
E(mouse.snseq.combined.sct.neurons.np.expression.filter.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.g)$weight>0)]$color <- "darkred"

# Convert edge weights to absolute values
E(mouse.snseq.combined.sct.neurons.np.expression.filter.g)$weight <- abs(E(mouse.snseq.combined.sct.neurons.np.expression.filter.g)$weight)

# Remove edges below absolute Pearson correlation 0.01
mouse.snseq.combined.sct.neurons.np.expression.filter.g <- delete_edges(mouse.snseq.combined.sct.neurons.np.expression.filter.g, 
                                                                        E(mouse.snseq.combined.sct.neurons.np.expression.filter.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.g)$weight<0.01)])

# # Assign names to the graph vertices (optional)
# V(g)$name <- V(g)$name

# # Change shape of graph vertices
# V(g)$shape <- "sphere"
# 
# # Change colour of graph vertices
# V(g)$color <- "skyblue"
# 
# # Change colour of vertex frames
# V(g)$vertex.frame.color <- "white"

# Scale the size of the vertices to be proportional to the level of expression of each gene represented by each vertex
# Multiply scaled vales by a factor of 10
scale01 <- function(x){(x-min(x))/(max(x)-min(x))}
vSizes.all <- (scale01(apply(mouse.snseq.combined.sct.neurons.np.expression.filter, 1, mean)) + 1.0) 

# # Amplify or decrease the width of the edges
# edgeweights <- E(g)$weight * 2.0

# # Convert the graph adjacency object into a minimum spanning tree based on Prim's algorithm
# mst <- mst(g, algorithm="prim")

## graph
mouse.snseq.combined.sct.neurons.np.expression.filter.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
         ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         edge_colour = color)) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
                      )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=10, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank())
ggsave('./neurons/neuropeptides/comparison/neuropeptides correlation network.png',
       height = 10,
       width = 10)


#### create network by sample
### get list of sample ids
mouse.snseq.combined.sct.neurons.np.expression.samples = mouse.snseq.combined.sct.neurons.np.expression  %>% 
  rownames_to_column('Cell.id') %>%  
  full_join(mouse.snseq.combined.sct.neurons@meta.data %>%
              rownames_to_column("Cell.id") %>% 
              dplyr::select(c(orig.ident,
                              Cell.id))) %>% 
  relocate(orig.ident, .after = Cell.id)

#### graph networks sample correlation ####
### create matrix per sample
### males
## dom
mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom = t(mouse.snseq.combined.sct.neurons.np.expression.filter) %>% 
  as.data.frame()
#create id list
Male.Dom.cell.ids = mouse.snseq.combined.sct.neurons.np.expression.samples %>% 
  filter(orig.ident == 'Male.Dom') %>% 
  pull(Cell.id)
#filter down cells
mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom = mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom %>% 
  filter(rownames(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom) %in% Male.Dom.cell.ids) 

## create graph object
mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g <- graph.adjacency(
  as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom, method="pearson"))),
  mode="undirected",
  weighted=TRUE,
  diag=FALSE
)

# Simplfy the adjacency object
mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g <- igraph::simplify(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g, remove.multiple=TRUE, remove.loops=TRUE)

# Colour negative correlation edges as blue
E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g)$weight<0)]$color <- "negative"

# Colour positive correlation edges as red
E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g)$weight>0)]$color <- "positive"

# Convert edge weights to absolute values
E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g)$weight <- abs(E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g)$weight)

# Remove edges below absolute Pearson correlation 0.01
mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g <- delete_edges(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g, 
                                                                        E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g)$weight<0.01)])

# # Assign names to the graph vertices (optional)
# V(g)$name <- V(g)$name

# # Change shape of graph vertices
# V(g)$shape <- "sphere"
# 
# # Change colour of graph vertices
# V(g)$color <- "skyblue"
# 
# # Change colour of vertex frames
# V(g)$vertex.frame.color <- "white"

# Scale the size of the vertices to be proportional to the level of expression of each gene represented by each vertex
# Multiply scaled vales by a factor of 10
scale01 <- function(x){(x-min(x))/(max(x)-min(x))}
vSizes.all <- (scale01(apply(mouse.snseq.combined.sct.neurons.np.expression.filter, 1, mean)) + 1.0) 

# # Amplify or decrease the width of the edges
# edgeweights <- E(g)$weight * 2.0

# # Convert the graph adjacency object into a minimum spanning tree based on Prim's algorithm
# mst <- mst(g, algorithm="prim")

## graph
mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         edge_colour = color)) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=10, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank()) +
  ggtitle('male dom')
ggsave('./neurons/neuropeptides/comparison/neuropeptides correlation network male dom.png',
       height = 10,
       width = 10)



## sub
mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub = t(mouse.snseq.combined.sct.neurons.np.expression.filter) %>% 
  as.data.frame()
#create id list
Male.sub.cell.ids = mouse.snseq.combined.sct.neurons.np.expression.samples %>% 
  filter(orig.ident == 'Male.Sub') %>% 
  pull(Cell.id)
#filter down cells
mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub = mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub %>% 
  filter(rownames(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub) %in% Male.sub.cell.ids) 


## create graph object
mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g <- graph.adjacency(
  as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub, method="pearson"))),
  mode="undirected",
  weighted=TRUE,
  diag=FALSE
)

# Simplfy the adjacency object
mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g <- igraph::simplify(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g, remove.multiple=TRUE, remove.loops=TRUE)

# Colour negative correlation edges as blue
E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g)$weight<0)]$color <- "negative"

# Colour positive correlation edges as red
E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g)$weight>0)]$color <- "positive"

# Convert edge weights to absolute values
E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g)$weight <- abs(E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g)$weight)

# Remove edges below absolute Pearson correlation 0.01
mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g <- delete_edges(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g, 
                                                                                 E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g)$weight<0.01)])

# # Assign names to the graph vertices (optional)
# V(g)$name <- V(g)$name

# # Change shape of graph vertices
# V(g)$shape <- "sphere"
# 
# # Change colour of graph vertices
# V(g)$color <- "skyblue"
# 
# # Change colour of vertex frames
# V(g)$vertex.frame.color <- "white"

# Scale the size of the vertices to be proportional to the level of expression of each gene represented by each vertex
# Multiply scaled vales by a factor of 10
scale01 <- function(x){(x-min(x))/(max(x)-min(x))}
vSizes.all <- (scale01(apply(mouse.snseq.combined.sct.neurons.np.expression.filter, 1, mean)) + 1.0) 

# # Amplify or decrease the width of the edges
# edgeweights <- E(g)$weight * 2.0

# # Convert the graph adjacency object into a minimum spanning tree based on Prim's algorithm
# mst <- mst(g, algorithm="prim")

## graph
mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         edge_colour = color)) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=10, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank()) +
  ggtitle('male sub')
ggsave('./neurons/neuropeptides/comparison/neuropeptides correlation network male sub.png',
       height = 10,
       width = 10)

### females
## dom
mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom = t(mouse.snseq.combined.sct.neurons.np.expression.filter) %>% 
  as.data.frame()
#create id list
female.Dom.cell.ids = mouse.snseq.combined.sct.neurons.np.expression.samples %>% 
  filter(orig.ident == 'Female.Dom') %>% 
  pull(Cell.id)
#filter down cells
mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom = mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom %>% 
  filter(rownames(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom) %in% female.Dom.cell.ids) 


## create graph object
mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g <- graph.adjacency(
  as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom, method="pearson"))),
  mode="undirected",
  weighted=TRUE,
  diag=FALSE
)

# Simplfy the adjacency object
mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g <- igraph::simplify(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g, remove.multiple=TRUE, remove.loops=TRUE)

# Colour negative correlation edges as blue
E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g)$weight<0)]$color <- "negative"

# Colour positive correlation edges as red
E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g)$weight>0)]$color <- "positive"

# Convert edge weights to absolute values
E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g)$weight <- abs(E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g)$weight)

# Remove edges below absolute Pearson correlation 0.01
mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g <- delete_edges(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g, 
                                                                                 E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g)$weight<0.01)])

# # Assign names to the graph vertices (optional)
# V(g)$name <- V(g)$name

# # Change shape of graph vertices
# V(g)$shape <- "sphere"
# 
# # Change colour of graph vertices
# V(g)$color <- "skyblue"
# 
# # Change colour of vertex frames
# V(g)$vertex.frame.color <- "white"

# Scale the size of the vertices to be proportional to the level of expression of each gene represented by each vertex
# Multiply scaled vales by a factor of 10
scale01 <- function(x){(x-min(x))/(max(x)-min(x))}
vSizes.all <- (scale01(apply(mouse.snseq.combined.sct.neurons.np.expression.filter, 1, mean)) + 1.0) 

# # Amplify or decrease the width of the edges
# edgeweights <- E(g)$weight * 2.0

# # Convert the graph adjacency object into a minimum spanning tree based on Prim's algorithm
# mst <- mst(g, algorithm="prim")

## graph
mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         edge_colour = color)) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=10, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank()) +
  ggtitle('female dom')
ggsave('./neurons/neuropeptides/comparison/neuropeptides correlation network female dom.png',
       height = 10,
       width = 10)



## sub
mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub = t(mouse.snseq.combined.sct.neurons.np.expression.filter) %>% 
  as.data.frame()
#create id list
female.sub.cell.ids = mouse.snseq.combined.sct.neurons.np.expression.samples %>% 
  filter(orig.ident == 'Female.Sub') %>% 
  pull(Cell.id)
#filter down cells
mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub = mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub %>% 
  filter(rownames(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub) %in% female.sub.cell.ids) 


## create graph object
mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g <- graph.adjacency(
  as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub, method="pearson"))),
  mode="undirected",
  weighted=TRUE,
  diag=FALSE
)

# Simplfy the adjacency object
mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g <- igraph::simplify(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g, remove.multiple=TRUE, remove.loops=TRUE)

# Colour negative correlation edges as blue
E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g)$weight<0)]$color <- "negative"

# Colour positive correlation edges as red
E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g)$weight>0)]$color <- "positive"

# Convert edge weights to absolute values
E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g)$weight <- abs(E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g)$weight)

# Remove edges below absolute Pearson correlation 0.01
mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g <- delete_edges(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g, 
                                                                                 E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g)[which(E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g)$weight<0.01)])

# # Assign names to the graph vertices (optional)
# V(g)$name <- V(g)$name

# # Change shape of graph vertices
# V(g)$shape <- "sphere"
# 
# # Change colour of graph vertices
# V(g)$color <- "skyblue"
# 
# # Change colour of vertex frames
# V(g)$vertex.frame.color <- "white"

# Scale the size of the vertices to be proportional to the level of expression of each gene represented by each vertex
# Multiply scaled vales by a factor of 10
scale01 <- function(x){(x-min(x))/(max(x)-min(x))}
vSizes.all <- (scale01(apply(mouse.snseq.combined.sct.neurons.np.expression.filter, 1, mean)) + 1.0) 

# # Amplify or decrease the width of the edges
# edgeweights <- E(g)$weight * 2.0

# # Convert the graph adjacency object into a minimum spanning tree based on Prim's algorithm
# mst <- mst(g, algorithm="prim")

## graph
mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         edge_colour = color)) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=10, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank())  +
  ggtitle('female sub')
ggsave('./neurons/neuropeptides/comparison/neuropeptides correlation network female sub.png',
       height = 10,
       width = 10)


#### graph networks per sample correlation poster ####
### get weight values for each sample
## max
dom.male.network.weight.max = E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g)$weight %>% 
  max()
sub.male.network.weight.max = E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g)$weight %>% 
  max()
dom.female.network.weight.max = E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g)$weight %>% 
  max()
sub.female.network.weight.max = E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g)$weight %>% 
  max()
## min
dom.male.network.weight.min = E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g)$weight %>% 
  min()
sub.male.network.weight.min = E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g)$weight %>% 
  min()
dom.female.network.weight.min = E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g)$weight %>% 
  min()
sub.female.network.weight.min = E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g)$weight %>% 
  min()

## make data frame
network.weight.df = data.frame(max.weight = c(dom.male.network.weight.max,sub.male.network.weight.max,dom.female.network.weight.max,sub.female.network.weight.max),
                               min.weight = c(dom.male.network.weight.min,sub.male.network.weight.min,dom.female.network.weight.min,sub.female.network.weight.min),
                               sample = c('dom.male',
                                          'sub.male',
                                          'dom.female',
                                          'sub.female'))

# add scale value per sample
network.weight.df = network.weight.df %>% 
  mutate(Group.max = max(max.weight),
         Group.min = max(min.weight)) %>% 
  mutate(scalingmax = 10*max.weight/Group.max,
         scalingmin = 1*min.weight/Group.min)

## males
# dom
mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         edge_colour = color)) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=20, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank(),
        legend.position = 'none') +
  ggtitle('Dominant Male') +
  scale_edge_color_manual(values = c('blue','red')) +
  scale_edge_width(range = c(1,4.42))+
  scale_edge_alpha(range = c(0,.442)) 
ggsave('./neurons/neuropeptides/comparison/neuropeptides correlation network male dom.pdf',
       height = 5.25,
       width = 5.25)

# sub
mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         edge_colour = color)) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=20, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank(),
        legend.position = 'none'
        ) +
  ggtitle('Subordinate Male') +
  scale_edge_color_manual(values = c('blue','red')) +
  scale_edge_width(range = c(1,10))+
scale_edge_alpha(range = c(0,1)) 
ggsave('./neurons/neuropeptides/comparison/neuropeptides correlation network male sub.pdf',
       height = 5.25,
       width = 5.25)


## females
# dom
mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         edge_colour = color)) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=20, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank(),
        legend.position = 'none') +
  ggtitle('Dominant Female') +
  scale_edge_color_manual(values = c('blue','red')) +
  scale_edge_width(range = c(1,4.04))+
  scale_edge_alpha(range = c(0,.404)) 
ggsave('./neurons/neuropeptides/comparison/neuropeptides correlation network female dom.pdf',
       height = 5.25,
       width = 5.25)

# sub
mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         edge_colour = color)) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=20, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank(),
        legend.position = 'none'
        ) +
  ggtitle('Subordinate Female') +
  scale_edge_color_manual(values = c('blue','red')) +
  scale_edge_width(range = c(1,7.27))+
  scale_edge_alpha(range = c(0,0.727)) 
ggsave('./neurons/neuropeptides/comparison/neuropeptides correlation network female sub.pdf',
       height = 5.25,
       width = 5.25)





#### graph networks sample presence ####




### create list of genes
# remove low expressing genes
# remove low expressing cells
mouse.snseq.combined.sct.neurons.np.expression.counts.filter = mouse.snseq.combined.sct.neurons.np.expression.counts %>% 
  remove_nonexp(method = "percentage",
                min_exp = 0.68,
                min_percentage_samples = .05)  %>% 
  t() %>% 
  remove_nonexp(method = "percentage",
                min_exp = 0.68,
                min_percentage_samples = .1) 


ncol(mouse.snseq.combined.sct.neurons.np.expression.counts.filter)
# 7437 cells out of 9779
nrow(mouse.snseq.combined.sct.neurons.np.expression.counts.filter)
# 17 genes out of 71


# Scale the size of the vertices to be proportional to the level of expression of each gene represented by each vertex
# Multiply scaled vales by a factor of 10
scale01 <- function(x){(x-min(x))/(max(x)-min(x))}
vSizes.all <- (scale01(apply(mouse.snseq.combined.sct.neurons.np.expression.counts.filter, 1, mean)) + 1.0) 

### create matrix per sample
### males
## dom
## create graph object
mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g <- graph.adjacency(
  crossprod(as.matrix(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts %>% 
                        dplyr::select(c(rownames(mouse.snseq.combined.sct.neurons.np.expression.counts.filter))))),
  mode="undirected",
  weighted=TRUE,
  diag=FALSE
)

# Simplfy the adjacency object
mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g <- igraph::simplify(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g, remove.multiple=TRUE, remove.loops=TRUE)

## graph
mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         # edge_colour = color
                         )) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=10, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank()) +
  ggtitle('male dom')
ggsave('./neurons/neuropeptides/comparison/neuropeptides presence network male dom.png',
       height = 10,
       width = 10)

## sub
## create graph object
mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g <- graph.adjacency(
  crossprod(as.matrix(mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts %>% 
                        dplyr::select(c(rownames(mouse.snseq.combined.sct.neurons.np.expression.counts.filter))))),
  mode="undirected",
  weighted=TRUE,
  diag=FALSE
)

# Simplfy the adjacency object
mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g <- igraph::simplify(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g, remove.multiple=TRUE, remove.loops=TRUE)

## graph
mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         # edge_colour = color
  )) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=10, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank()) +
  ggtitle('male sub')
ggsave('./neurons/neuropeptides/comparison/neuropeptides presence network male sub.png',
       height = 10,
       width = 10)

### females
## dom
## create graph object
mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g <- graph.adjacency(
  crossprod(as.matrix(mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts %>% 
                        dplyr::select(c(rownames(mouse.snseq.combined.sct.neurons.np.expression.counts.filter))))),
  mode="undirected",
  weighted=TRUE,
  diag=FALSE
)

# Simplfy the adjacency object
mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g <- igraph::simplify(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g, remove.multiple=TRUE, remove.loops=TRUE)

## graph
mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         # edge_colour = color
  )) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=10, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank()) +
  ggtitle('female dom')
ggsave('./neurons/neuropeptides/comparison/neuropeptides presence network female dom.png',
       height = 10,
       width = 10)

## sub
## create graph object
mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g <- graph.adjacency(
  crossprod(as.matrix(mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts %>% 
                        dplyr::select(c(rownames(mouse.snseq.combined.sct.neurons.np.expression.counts.filter))))),
  mode="undirected",
  weighted=TRUE,
  diag=FALSE
)

# Simplfy the adjacency object
mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g <- igraph::simplify(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g, remove.multiple=TRUE, remove.loops=TRUE)

## graph
mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         # edge_colour = color
  )) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=10, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank()) +
  ggtitle('female sub')
ggsave('./neurons/neuropeptides/comparison/neuropeptides presence network female sub.png',
       height = 10,
       width = 10)


#### ordinal linear regression ####
library(ordinal)
### run with cells per status
## create dataframe
neuropeptides.per.neuron.df.ord = neuropeptides.per.neuron.df %>% 
  select(NP.count,
         orig.ident) %>% 
  separate_wider_delim(cols = orig.ident,
                       delim = '.',
                       names = c('Sex',
                                 'Status'))

# Convert NP.count to an ordered factor
neuropeptides.per.neuron.df.ord$NP.count <- factor(neuropeptides.per.neuron.df.ord$NP.count, 
                                                   ordered = TRUE)

## ordinal logistic regression
neuropeptides.ord.model <- clm(NP.count ~ Sex*Status, 
                               data = neuropeptides.per.neuron.df.ord)
# results
summary(neuropeptides.ord.model)
anova(neuropeptides.ord.model)

### run with cells per individual genotype
## create dataframe
neuropeptides.per.neuron.df.geno.ord = neuropeptides.per.neuron.df.geno %>% 
  select(NP.count,
         orig.ident,
         Genotype.id) %>% 
  separate_wider_delim(cols = orig.ident,
                       delim = '.',
                       names = c('Sex',
                                 'Status'))

# Convert NP.count to an ordered factor
neuropeptides.per.neuron.df.geno.ord$NP.count <- factor(neuropeptides.per.neuron.df.geno.ord$NP.count, 
                                                   ordered = TRUE)

## ordinal logistic regression
neuropeptides.ord.geno.model <- clmm(NP.count ~ Sex*Status+(1|Genotype.id), 
                               data = neuropeptides.per.neuron.df.geno.ord)
# results
summary(neuropeptides.ord.geno.model)
ranef(neuropeptides.ord.geno.model)

### graph neuron counts
neuropeptides.per.neuron.df.geno.ord %>% 
  select(Genotype.id,Sex,Status) %>% 
  table() %>% 
  as.data.frame() %>% 
  filter(Freq != 0) %>% 
  ggplot(aes(y = Freq,
             x = Status,
             color = Sex,
             shape = Status))+
  geom_point() +
  ylim(0,1300) +
  theme_classic() +
  facet_grid(~Sex) +
  ylab('Neurons per sample') +
   xlab('')
ggsave('neurons/neuron_count_per_sample.png')

#### graph networks per sample presence poster ####
### get weight values for each sample
## max
dom.male.network.weight.max = E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g)$weight %>% 
  max()
sub.male.network.weight.max = E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g)$weight %>% 
  max()
dom.female.network.weight.max = E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g)$weight %>% 
  max()
sub.female.network.weight.max = E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g)$weight %>% 
  max()
## min
dom.male.network.weight.min = E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g)$weight %>% 
  min()
sub.male.network.weight.min = E(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g)$weight %>% 
  min()
dom.female.network.weight.min = E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g)$weight %>% 
  min()
sub.female.network.weight.min = E(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g)$weight %>% 
  min()

## make data frame
network.weight.df = data.frame(max.weight = c(dom.male.network.weight.max,sub.male.network.weight.max,dom.female.network.weight.max,sub.female.network.weight.max),
                               min.weight = c(dom.male.network.weight.min,sub.male.network.weight.min,dom.female.network.weight.min,sub.female.network.weight.min),
                               sample = c('dom.male',
                                          'sub.male',
                                          'dom.female',
                                          'sub.female'))

# add scale value per sample
network.weight.df = network.weight.df %>% 
  mutate(Group.max = max(max.weight),
         Group.min = max(min.weight)) %>% 
  mutate(scalingmax = 10*max.weight/Group.max,
         scalingmin = 1*min.weight/Group.min)

## males
# dom
mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         # edge_colour = color
                         )) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=20, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank(),
        legend.position = 'none') +
  ggtitle('Dominant Male') +
  # scale_edge_color_manual(values = c('blue','red')) +
  scale_edge_width(range = c(1,5.36))+
  scale_edge_alpha(range = c(0,0.536)) 
ggsave('./neurons/neuropeptides/comparison/neuropeptides presence network male dom.pdf',
       height = 5.25,
       width = 5.25)

# sub
mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         # edge_colour = color
                         )) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=20, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank(),
        legend.position = 'none'
  ) +
  ggtitle('Subordinate Male') +
  # scale_edge_color_manual(values = c('blue','red')) +
  scale_edge_width(range = c(0.848,10))+
  scale_edge_alpha(range = c(0,1)) 
ggsave('./neurons/neuropeptides/comparison/neuropeptides presence network male sub.pdf',
       height = 5.25,
       width = 5.25)


## females
# dom
mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         # edge_colour = color
                         )) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=20, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank(),
        legend.position = 'none') +
  ggtitle('Dominant Female') +
  # scale_edge_color_manual(values = c('blue','red')) +
  scale_edge_width(range = c(.33, 9.5))+
  scale_edge_alpha(range = c(0,.950)) 
ggsave('./neurons/neuropeptides/comparison/neuropeptides presence network female dom.pdf',
       height = 5.25,
       width = 5.25)

# sub
mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub.g %>%
  ggraph(layout = 'linear',
         circular = TRUE,
         sort.by = vSizes.all
  ) +
  geom_edge_parallel(aes(width = weight ,
                         alpha = weight ,
                         start_cap = label_rect(node1.name),
                         end_cap = label_rect(node2.name),
                         # edge_colour = color
                         )) +
  geom_node_label(aes(label = name,
                      size = vSizes.all
  )) +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        title =element_text(size=20, face='bold'),
        axis.line =element_blank(),
        axis.title =element_blank(),
        axis.ticks  =element_blank(),
        axis.text =element_blank(),
        legend.position = 'none'
  ) +
  ggtitle('Subordinate Female') +
  # scale_edge_color_manual(values = c('blue','red')) +
  scale_edge_width(range = c(.303,6.15))+
  scale_edge_alpha(range = c(0,0.615)) 
ggsave('./neurons/neuropeptides/comparison/neuropeptides presence network female sub.pdf',
       height = 5.25,
       width = 5.25)





#### network statistics #### 
#### pairs mantel test
### compare across samples
## filtered data
# mantel.np.filtered.genes <- as.lpcor(as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom, method="pearson"))),
#                    as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub, method="pearson"))),
#                    as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom, method="pearson"))),
#                    as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub, method="pearson")))) %>%
#   pairs_mantel.pvalue()
# # rename labels
# mantel.np.filtered.genes[["xAxisLabels"]]  = c("Male.Dom",
#                                                "Male.Sub",
#                                                'Female.Dom',
#                                                'Female.Sub')
# mantel.np.filtered.genes[["yAxisLabels"]]  = c("Male.Dom",
#                                                "Male.Sub",
#                                                'Female.Dom',
#                                                'Female.Sub')
# mantel.np.filtered.genes[["title"]] = paste0( mantel.np.filtered.genes[["title"]],
#                                          ' filter')
# mantel.np.filtered.genes
# ggsave('./neurons/neuropeptides/comparison/Mantel test filter.png',
#        height = 10,
#        width = 10)


### all genes
## create matrices
#males
#dom
mouse.snseq.combined.sct.neurons.np.expression.male.dom = mouse.snseq.combined.sct.neurons.np.expression %>% 
  as.data.frame()
#filter down cells
mouse.snseq.combined.sct.neurons.np.expression.male.dom = mouse.snseq.combined.sct.neurons.np.expression.male.dom %>% 
  filter(rownames(mouse.snseq.combined.sct.neurons.np.expression.male.dom) %in% Male.Dom.cell.ids)
# filter out genes with all zeros
mouse.snseq.combined.sct.neurons.np.expression.male.dom = mouse.snseq.combined.sct.neurons.np.expression.male.dom %>% 
  select_if(colSums(.) != 0)
#sub
mouse.snseq.combined.sct.neurons.np.expression.male.sub = mouse.snseq.combined.sct.neurons.np.expression %>% 
  as.data.frame()
#filter down cells
mouse.snseq.combined.sct.neurons.np.expression.male.sub = mouse.snseq.combined.sct.neurons.np.expression.male.sub %>% 
  filter(rownames(mouse.snseq.combined.sct.neurons.np.expression.male.sub) %in% Male.sub.cell.ids) 
# filter out genes with all zeros
mouse.snseq.combined.sct.neurons.np.expression.male.sub = mouse.snseq.combined.sct.neurons.np.expression.male.sub %>% 
  select_if(colSums(.) != 0)
## females
#dom
mouse.snseq.combined.sct.neurons.np.expression.female.dom = mouse.snseq.combined.sct.neurons.np.expression %>% 
  as.data.frame()
#filter down cells
mouse.snseq.combined.sct.neurons.np.expression.female.dom = mouse.snseq.combined.sct.neurons.np.expression.female.dom %>% 
  filter(rownames(mouse.snseq.combined.sct.neurons.np.expression.female.dom) %in% female.Dom.cell.ids)
# filter out genes with all zeros
mouse.snseq.combined.sct.neurons.np.expression.female.dom = mouse.snseq.combined.sct.neurons.np.expression.female.dom %>% 
  select_if(colSums(.) != 0)
#sub
mouse.snseq.combined.sct.neurons.np.expression.female.sub = mouse.snseq.combined.sct.neurons.np.expression %>% 
  as.data.frame()
#filter down cells
mouse.snseq.combined.sct.neurons.np.expression.female.sub = mouse.snseq.combined.sct.neurons.np.expression.female.sub %>% 
  filter(rownames(mouse.snseq.combined.sct.neurons.np.expression.female.sub) %in% female.sub.cell.ids) 
# filter out genes with all zeros
mouse.snseq.combined.sct.neurons.np.expression.female.sub = mouse.snseq.combined.sct.neurons.np.expression.female.sub %>% 
  select_if(colSums(.) != 0)

## make sure all samples have the same genes
overlaping.genes.subject = intersect(colnames(mouse.snseq.combined.sct.neurons.np.expression.female.sub),
          colnames(mouse.snseq.combined.sct.neurons.np.expression.female.dom)) %>% 
            intersect(colnames(mouse.snseq.combined.sct.neurons.np.expression.male.sub)) %>% 
  intersect(colnames(mouse.snseq.combined.sct.neurons.np.expression.male.dom))

## filter out genes that have all zero in at least one sample
##males
#dom
mouse.snseq.combined.sct.neurons.np.expression.male.dom = mouse.snseq.combined.sct.neurons.np.expression.male.dom %>% 
  dplyr::select(all_of(overlaping.genes.subject))
#sub
mouse.snseq.combined.sct.neurons.np.expression.male.sub = mouse.snseq.combined.sct.neurons.np.expression.male.sub %>% 
  dplyr::select(all_of(overlaping.genes.subject))
##females
#dom
mouse.snseq.combined.sct.neurons.np.expression.female.dom = mouse.snseq.combined.sct.neurons.np.expression.female.dom %>% 
  dplyr::select(all_of(overlaping.genes.subject))
#sub
mouse.snseq.combined.sct.neurons.np.expression.female.sub = mouse.snseq.combined.sct.neurons.np.expression.female.sub %>% 
  dplyr::select(all_of(overlaping.genes.subject))

## create distance matrix of correlation matrix for mantel test
## male
# dom
mouse.np.male.dom.matrix.dist = as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.male.dom, method="pearson"))
# sub
mouse.np.male.sub.matrix.dist = as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.male.sub, method="pearson"))
## female
# dom
mouse.np.female.dom.matrix.dist = as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.female.dom, method="pearson"))
# sub
mouse.np.female.sub.matrix.dist = as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.female.sub, method="pearson"))

## create correlation matrix for mantel test
## male
# dom
mouse.np.male.dom.matrix = as.matrix(mouse.np.male.dom.matrix.dist)
# sub
mouse.np.male.sub.matrix = as.matrix(mouse.np.male.sub.matrix.dist)
## female
# dom
mouse.np.female.dom.matrix = as.matrix(mouse.np.female.dom.matrix.dist)
# sub
mouse.np.female.sub.matrix = as.matrix(mouse.np.female.sub.matrix.dist)

# ### run mantel across samples
# mantel.np.all.genes = as.lpcor(mouse.np.male.dom.matrix,
#          mouse.np.male.sub.matrix,
#          mouse.np.female.dom.matrix,
#          mouse.np.female.sub.matrix) %>%
#   pairs_mantel.pvalue()
# # rename labels
# mantel.np.all.genes[["xAxisLabels"]]  = c("Male.Dom",
#                                                "Male.Sub",
#                                                'Female.Dom',
#                                                'Female.Sub')
# mantel.np.all.genes[["yAxisLabels"]]  = c("Male.Dom",
#                                                "Male.Sub",
#                                                'Female.Dom',
#                                                'Female.Sub')
# mantel.np.all.genes[["title"]] = paste0( mantel.np.all.genes[["title"]],
#                                         ' all')
# mantel.np.all.genes
# ggsave('./neurons/neuropeptides/comparison/Mantel test all.png',
#        height = 10,
#        width = 10)


#### confidence interval mantel test
#### run mantel across samples
### all genes
# mantel.np.all.genes.ci = as.lpcor(mouse.np.male.dom.matrix,
#                                mouse.np.male.sub.matrix,
#                                mouse.np.female.dom.matrix,
#                                mouse.np.female.sub.matrix) %>%
#   pairs_mantel.ci()
# # rename labels
# mantel.np.all.genes.ci[["xAxisLabels"]]  = c("Male.Dom",
#                                           "Male.Sub",
#                                           'Female.Dom',
#                                           'Female.Sub')
# mantel.np.all.genes.ci[["yAxisLabels"]]  = c("Male.Dom",
#                                           "Male.Sub",
#                                           'Female.Dom',
#                                           'Female.Sub')
# mantel.np.all.genes.ci[["title"]] = paste0( mantel.np.all.genes.ci[["title"]],
#                                          ' all ci')
# mantel.np.all.genes.ci
# ggsave('./neurons/neuropeptides/comparison/Mantel test all ci.png',
#        height = 10,
#        width = 10)

### filter genes
# mantel.np.filter.genes.ci = as.lpcor(as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.filter.male.dom, method="pearson"))),
#                                      as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.filter.male.sub, method="pearson"))),
#                                      as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.filter.female.dom, method="pearson"))),
#                                      as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.filter.female.sub, method="pearson")))) %>%
#   pairs_mantel.ci()
# # rename labels
# mantel.np.filter.genes.ci[["xAxisLabels"]]  = c("Male.Dom",
#                                              "Male.Sub",
#                                              'Female.Dom',
#                                              'Female.Sub')
# mantel.np.filter.genes.ci[["yAxisLabels"]]  = c("Male.Dom",
#                                              "Male.Sub",
#                                              'Female.Dom',
#                                              'Female.Sub')
# mantel.np.filter.genes.ci[["title"]] = paste0( mantel.np.filter.genes.ci[["title"]],
#                                             ' filter ci')
# mantel.np.filter.genes.ci
# ggsave('./neurons/neuropeptides/comparison/Mantel test filter ci.png',
#        height = 10,
#        width = 10)


#### threshold cells
### get list of genes to filter
filter.50.genes.subject = mouse.snseq.combined.sct.neurons.np.expression.samples.counts.total %>% 
  filter(Counts >= 50) %>% 
  pull(gene) %>% 
  unique() 

## create matrices
#males
#dom
mouse.snseq.combined.sct.neurons.np.expression.male.dom.filter = mouse.snseq.combined.sct.neurons.np.expression %>% 
  as.data.frame()
#filter down cells
mouse.snseq.combined.sct.neurons.np.expression.male.dom.filter = mouse.snseq.combined.sct.neurons.np.expression.male.dom.filter %>% 
  filter(rownames(mouse.snseq.combined.sct.neurons.np.expression.male.dom.filter) %in% Male.Dom.cell.ids)

#sub
mouse.snseq.combined.sct.neurons.np.expression.male.sub.filter = mouse.snseq.combined.sct.neurons.np.expression %>% 
  as.data.frame()
#filter down cells
mouse.snseq.combined.sct.neurons.np.expression.male.sub.filter = mouse.snseq.combined.sct.neurons.np.expression.male.sub.filter %>% 
  filter(rownames(mouse.snseq.combined.sct.neurons.np.expression.male.sub.filter) %in% Male.sub.cell.ids) 

## females
#dom
mouse.snseq.combined.sct.neurons.np.expression.female.dom.filter = mouse.snseq.combined.sct.neurons.np.expression %>% 
  as.data.frame()
#filter down cells
mouse.snseq.combined.sct.neurons.np.expression.female.dom.filter = mouse.snseq.combined.sct.neurons.np.expression.female.dom.filter %>% 
  filter(rownames(mouse.snseq.combined.sct.neurons.np.expression.female.dom.filter) %in% female.Dom.cell.ids)

#sub
mouse.snseq.combined.sct.neurons.np.expression.female.sub.filter = mouse.snseq.combined.sct.neurons.np.expression %>% 
  as.data.frame()
#filter down cells
mouse.snseq.combined.sct.neurons.np.expression.female.sub.filter = mouse.snseq.combined.sct.neurons.np.expression.female.sub.filter %>% 
  filter(rownames(mouse.snseq.combined.sct.neurons.np.expression.female.sub.filter) %in% female.sub.cell.ids) 

## filter out genes that are below cell count threshold
##males
#dom
mouse.snseq.combined.sct.neurons.np.expression.male.dom.filter = mouse.snseq.combined.sct.neurons.np.expression.male.dom.filter %>% 
  dplyr::select(all_of(filter.50.genes.subject))
#sub
mouse.snseq.combined.sct.neurons.np.expression.male.sub.filter = mouse.snseq.combined.sct.neurons.np.expression.male.sub.filter %>% 
  dplyr::select(all_of(filter.50.genes.subject))
##females
#dom
mouse.snseq.combined.sct.neurons.np.expression.female.dom.filter = mouse.snseq.combined.sct.neurons.np.expression.female.dom.filter %>% 
  dplyr::select(all_of(filter.50.genes.subject))
#sub
mouse.snseq.combined.sct.neurons.np.expression.female.sub.filter = mouse.snseq.combined.sct.neurons.np.expression.female.sub.filter %>% 
  dplyr::select(all_of(filter.50.genes.subject))


## make sure all samples have the same genes
#33
intersect(colnames(mouse.snseq.combined.sct.neurons.np.expression.male.dom.filter),
                                     colnames(mouse.snseq.combined.sct.neurons.np.expression.male.sub.filter)) %>%
  intersect(colnames(mouse.snseq.combined.sct.neurons.np.expression.female.dom.filter)) %>%
  intersect(colnames(mouse.snseq.combined.sct.neurons.np.expression.female.sub.filter))

### need to add a single count to PRL in sub male
## not needed anymore?
## sub male
# add count of 1.1 [log(1.1 = 0.095)] to PRL cell
# mouse.snseq.combined.sct.neurons.np.expression.male.sub.filter$PRL[1] = 0.095

### filter 50 genes
mantel.np.filter.50.genes.ci = as.lpcor(as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.male.dom.filter, method="pearson"))),
                                     as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.male.sub.filter, method="pearson"))),
                                     as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.female.dom.filter, method="pearson"))),
                                     as.matrix(as.dist(cor(mouse.snseq.combined.sct.neurons.np.expression.female.sub.filter, method="pearson")))) %>%
  pairs_mantel.ci()
# rename labels
mantel.np.filter.50.genes.ci[["xAxisLabels"]]  = c("Male.Dom",
                                                "Male.Sub",
                                                'Female.Dom',
                                                'Female.Sub')
mantel.np.filter.50.genes.ci[["yAxisLabels"]]  = c("Male.Dom",
                                                "Male.Sub",
                                                'Female.Dom',
                                                'Female.Sub')
mantel.np.filter.50.genes.ci[["title"]] = paste0( mantel.np.filter.50.genes.ci[["title"]],
                                               ' filter 50 ci')
mantel.np.filter.50.genes.ci
ggsave('./neurons/neuropeptides/comparison/Mantel test filter 50 ci.png',
       height = 10,
       width = 10)

### graph forest plot
## create data frame with values
forest.plot.df = data.frame(Comparisons = c('Males',
                                        'Females',
                                        'Dominants',
                                        'Subordinates'),
                            Mantel.value = c(0.6,
                                             0.22,
                                             0.27,
                                             0.41),
                            Mantel.value.low = c(0.53,
                                             0.1,
                                             0.17,
                                             0.27),
                            Mantel.value.high = c(0.66,
                                             0.29,
                                             0.34,
                                             0.48),
                            Comparison.type = c(1,
                                                2,
                                                3,
                                                4))


## graph
forest.plot.df %>% 
  ggplot(aes(y=reorder(Comparisons,
                       -Comparison.type), 
             x=Mantel.value,
             xmin=Mantel.value.low, 
             xmax=Mantel.value.high)) +
  geom_point(size = 3) + 
  geom_errorbarh(height=.5) +
  geom_hline(yintercept = 2.5,
             linetype = 'dashed') +
  theme_classic() +
  xlab('Mantel test r 95% confidence') +
  ylab('Comparisons') +
  ggtitle('Neuropeptide Network Comparison') +
  theme(text = element_text(size = 15)) 
ggsave('./neurons/neuropeptides/comparison/Mantel test forest plot ci.pdf',
       height = 5.25,
       width = 5.25)








#### testing covariance matrices old? ####
### create covariance matrix per sample
# library(HDtest)
library(parallel)


mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts

### run hd test
males.hd = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.dom.filter, 
        mouse.snseq.combined.sct.neurons.np.expression.male.sub.filter, 
        method = "HD",
        J = 1000, 
        alpha = 0.05, 
        n.core = 12)

females.hd = testCov(mouse.snseq.combined.sct.neurons.np.expression.female.dom.filter, 
        mouse.snseq.combined.sct.neurons.np.expression.female.sub.filter, 
        method = "HD",
        J = 1000, 
        alpha = 0.05, 
        n.core = 12)

doms.hd = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.dom.filter, 
        mouse.snseq.combined.sct.neurons.np.expression.female.dom.filter, 
        method = "HD",
        J = 1000, 
        alpha = 0.05, 
        n.core = 12)

subs.hd = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.sub.filter, 
        mouse.snseq.combined.sct.neurons.np.expression.female.sub.filter, 
        method = "HD",
        J = 1000, 
        alpha = 0.05, 
        n.core = 12)

## run clx test
males.CLX = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.dom.filter, 
                   mouse.snseq.combined.sct.neurons.np.expression.male.sub.filter, 
                   method = "CLX",
                   J = 1000, 
                   alpha = 0.05, 
                   n.core = 12)

females.CLX = testCov(mouse.snseq.combined.sct.neurons.np.expression.female.dom.filter, 
                     mouse.snseq.combined.sct.neurons.np.expression.female.sub.filter, 
                     method = "CLX",
                     J = 1000, 
                     alpha = 0.05, 
                     n.core = 12)

doms.CLX = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.dom.filter, 
                  mouse.snseq.combined.sct.neurons.np.expression.female.dom.filter, 
                  method = "CLX",
                  J = 1000, 
                  alpha = 0.05, 
                  n.core = 12)

subs.CLX = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.sub.filter, 
                  mouse.snseq.combined.sct.neurons.np.expression.female.sub.filter, 
                  method = "CLX",
                  J = 1000, 
                  alpha = 0.05, 
                  n.core = 12)


#### create dataframe
results.testcov = data.frame(comparison = c('Male','Females','Doms','Subs'),
         HD.p.val = c(males.hd[[2]],
                      females.hd[[2]],
                      doms.hd[[2]],
                      subs.hd[[2]]),
         HD.stat = c(males.hd[[1]],
                      females.hd[[1]],
                      doms.hd[[1]],
                      subs.hd[[1]]),
         CLX.p.val = c(males.CLX[[2]],
                      females.CLX[[2]],
                      doms.CLX[[2]],
                      subs.CLX[[2]]),
         CLX.stat = c(males.CLX[[1]],
                     females.CLX[[1]],
                     doms.CLX[[1]],
                     subs.CLX[[1]])
         )
results.testcov

# results.testcov.short = data.frame(comparison = c('Male','Females','Doms','Subs'),
#                              HD.stat = round(c(males.hd[[1]],
#                                          females.hd[[1]],
#                                          doms.hd[[1]],
#                                          subs.hd[[1]])),
#                              CLX.stat = round(c(males.CLX[[1]],
#                                           females.CLX[[1]],
#                                           doms.CLX[[1]],
#                                           subs.CLX[[1]]))
#                              )












#### Kolmogorov-Smirnov Tests on distribution ####
## pairwise testing
MSMD = ks.test(neuropeptides.per.neuron.df %>% 
                 filter(orig.ident == 'Male.Sub') %>% 
                 pull(NP.count),
               neuropeptides.per.neuron.df %>% 
                 filter(orig.ident == 'Male.Dom') %>% 
                 pull(NP.count),
               simulate.p.value	= T)

MSFD = ks.test(neuropeptides.per.neuron.df %>% 
          filter(orig.ident == 'Male.Sub') %>% 
          pull(NP.count),
        neuropeptides.per.neuron.df %>% 
          filter(orig.ident == 'Female.Dom') %>% 
          pull(NP.count),
        simulate.p.value	= T)

MSFS = ks.test(neuropeptides.per.neuron.df %>% 
          filter(orig.ident == 'Male.Sub') %>% 
          pull(NP.count),
        neuropeptides.per.neuron.df %>% 
          filter(orig.ident == 'Female.Sub') %>% 
          pull(NP.count),
        simulate.p.value	= T)

FSFD = ks.test(neuropeptides.per.neuron.df %>% 
          filter(orig.ident == 'Female.Sub') %>% 
          pull(NP.count),
        neuropeptides.per.neuron.df %>% 
          filter(orig.ident == 'Female.Dom') %>% 
          pull(NP.count),
        simulate.p.value	= T)


FSMD = ks.test(neuropeptides.per.neuron.df %>% 
          filter(orig.ident == 'Female.Sub') %>% 
          pull(NP.count),
        neuropeptides.per.neuron.df %>% 
          filter(orig.ident == 'Male.Dom') %>% 
          pull(NP.count),
        simulate.p.value	= T)

FDMD = ks.test(neuropeptides.per.neuron.df %>% 
          filter(orig.ident == 'Female.Dom') %>% 
          pull(NP.count),
        neuropeptides.per.neuron.df %>% 
          filter(orig.ident == 'Male.Dom') %>% 
          pull(NP.count),
        simulate.p.value	= T)

## combine testing
ks_test_neuropeptides_results = data.frame(contrasts = c('Male.Sub vs Male.Dom',
                                                         'Male.Sub vs Female.Dom',
                                                         'Male.Sub vs Female.Sub',
                                                         'Female.Sub vs Female.Dom',
                                                         'Female.Sub vs Male.Dom',
                                                         'Female.Dom vs Male.Dom'),
                                           D.statistic = c(MSMD$statistic,
                                                           MSFD$statistic,
                                                           MSFS$statistic,
                                                           FSFD$statistic,
                                                           FSMD$statistic,
                                                           FDMD$statistic),
                                           p.value = c(MSMD$p.value,
                                                       MSFD$p.value,
                                                       MSFS$p.value,
                                                       FSFD$p.value,
                                                       FSMD$p.value,
                                                       FDMD$p.value))

## save data
write_csv(ks_test_neuropeptides_results,
          'neurons/neuropeptides/comparison/ks_test_neuropeptides_results.csv')




#### testing covariance matrices ####
### use presence absence matrix
# library(HDtest)
library(doParallel)
library(parallel)
library(PEtests)

### create filtered matrices 
## male
# dom
mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.filter = as.matrix(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts %>%
                                                                                    dplyr::select(c(rownames(mouse.snseq.combined.sct.neurons.np.expression.counts.filter))))
# sub
mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.filter = as.matrix(mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts %>%
                                                                                    dplyr::select(c(rownames(mouse.snseq.combined.sct.neurons.np.expression.counts.filter))))

## female
# dom
mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.filter = as.matrix(mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts %>%
                                                                                    dplyr::select(c(rownames(mouse.snseq.combined.sct.neurons.np.expression.counts.filter))))
# sub
mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.filter = as.matrix(mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts %>%
                                                                                    dplyr::select(c(rownames(mouse.snseq.combined.sct.neurons.np.expression.counts.filter))))



### run hd test
males.hd = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.filter, 
                   mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.filter, 
                   method = "HD",
                   J = 1000, 
                   alpha = 0.05, 
                   n.core = 12)

females.hd = testCov(mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.filter, 
                     mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.filter, 
                     method = "HD",
                     J = 1000, 
                     alpha = 0.05, 
                     n.core = 12)

doms.hd = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.filter, 
                  mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.filter, 
                  method = "HD",
                  J = 1000, 
                  alpha = 0.05, 
                  n.core = 12)

subs.hd = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.filter, 
                  mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.filter, 
                  method = "HD",
                  J = 1000, 
                  alpha = 0.05, 
                  n.core = 12)

## run clx test
males.CLX = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.filter, 
                    mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.filter, 
                    method = "CLX",
                    J = 1000, 
                    alpha = 0.05, 
                    n.core = 12)

females.CLX = testCov(mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.filter, 
                      mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.filter, 
                      method = "CLX",
                      J = 1000, 
                      alpha = 0.05, 
                      n.core = 12)

doms.CLX = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.filter, 
                   mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.filter, 
                   method = "CLX",
                   J = 1000, 
                   alpha = 0.05, 
                   n.core = 12)

subs.CLX = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.filter, 
                   mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.filter, 
                   method = "CLX",
                   J = 1000, 
                   alpha = 0.05, 
                   n.core = 12)

## run LC test
males.LC = covtest.lc(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.filter, 
                    mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.filter)

females.LC = covtest.lc(mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.filter, 
                      mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.filter)

doms.LC = covtest.lc(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.filter, 
                   mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.filter)

subs.LC = covtest.lc(mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.filter, 
                   mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.filter)

#### create dataframe
results.testcov = data.frame(comparison = c('Male','Females','Doms','Subs'),
                             HD.p.val = c(males.hd[[2]],
                                          females.hd[[2]],
                                          doms.hd[[2]],
                                          subs.hd[[2]]),
                             HD.stat = c(males.hd[[1]],
                                         females.hd[[1]],
                                         doms.hd[[1]],
                                         subs.hd[[1]]),
                             CLX.p.val = c(males.CLX[[2]],
                                           females.CLX[[2]],
                                           doms.CLX[[2]],
                                           subs.CLX[[2]]),
                             CLX.stat = c(males.CLX[[1]],
                                          females.CLX[[1]],
                                          doms.CLX[[1]],
                                          subs.CLX[[1]]),
                             LC.p.val = c(males.LC$pval,
                                         females.LC$pval,
                                         doms.LC$pval,
                                         subs.LC$pval),
                             LC.stat = c(males.LC$stat,
                                          females.LC$stat,
                                          doms.LC$stat,
                                          subs.LC$stat)
)
results.testcov


### run hd test
### use all genes
## convert to matrix
mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.mat = as.matrix(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts %>%
                                                                                 select(where(~ any(. != 0))))
mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.mat = as.matrix(mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts %>%
                                                                                 select(where(~ any(. != 0))))
mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.mat = as.matrix(mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts %>%
                                                                                   select(where(~ any(. != 0))))
mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.mat = as.matrix(mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts %>%
                                                                                   select(where(~ any(. != 0))))

## create list of genes to use
gene.list.np = mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.mat %>% 
  colnames() %>% 
  intersect(mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.mat %>% 
  colnames())%>% 
  intersect(mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.mat %>% 
  colnames()) %>% 
  intersect(mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.mat %>% 
        colnames())

## remove genes with 0 in one sample
mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.mat = mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.mat %>%
  as.data.frame() %>% 
  dplyr::select(any_of(gene.list.np)) %>% 
  as.matrix()
mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.mat = mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.mat %>%
  as.data.frame() %>% 
  dplyr::select(any_of(gene.list.np)) %>% 
  as.matrix()
mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.mat = mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.mat %>%
  as.data.frame() %>% 
  dplyr::select(any_of(gene.list.np)) %>% 
  as.matrix()
mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.mat = mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.mat %>%
  as.data.frame() %>% 
  dplyr::select(any_of(gene.list.np)) %>% 
  as.matrix()
  
## run tests
males.hd = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.mat, 
                   mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.mat, 
                   method = "HD",
                   J = 1000, 
                   alpha = 0.05, 
                   n.core = 12)

females.hd = testCov(mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.mat, 
                     mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.mat, 
                     method = "HD",
                     J = 1000, 
                     alpha = 0.05, 
                     n.core = 12)

doms.hd = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.mat, 
                  mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.mat, 
                  method = "HD",
                  J = 1000, 
                  alpha = 0.05, 
                  n.core = 12)

subs.hd = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.mat, 
                  mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.mat, 
                  method = "HD",
                  J = 1000, 
                  alpha = 0.05, 
                  n.core = 12)

## run clx test
males.CLX = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.mat, 
                    mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.mat, 
                    method = "CLX",
                    J = 1000, 
                    alpha = 0.05, 
                    n.core = 12)

females.CLX = testCov(mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.mat, 
                      mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.mat, 
                      method = "CLX",
                      J = 1000, 
                      alpha = 0.05, 
                      n.core = 12)

doms.CLX = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.mat, 
                   mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.mat, 
                   method = "CLX",
                   J = 1000, 
                   alpha = 0.05, 
                   n.core = 12)

subs.CLX = testCov(mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.mat, 
                   mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.mat, 
                   method = "CLX",
                   J = 1000, 
                   alpha = 0.05, 
                   n.core = 12)

## run LC test
males.LC = covtest.lc(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.mat, 
                      mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.mat)

females.LC = covtest.lc(mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.mat, 
                        mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.mat)

doms.LC = covtest.lc(mouse.snseq.combined.sct.neurons.np.expression.male.dom.counts.mat, 
                     mouse.snseq.combined.sct.neurons.np.expression.female.dom.counts.mat)

subs.LC = covtest.lc(mouse.snseq.combined.sct.neurons.np.expression.male.sub.counts.mat, 
                     mouse.snseq.combined.sct.neurons.np.expression.female.sub.counts.mat)

#### create dataframe
results.testcov.all = data.frame(comparison = c('Male','Females','Doms','Subs'),
                             HD.p.val = c(males.hd[[2]],
                                          females.hd[[2]],
                                          doms.hd[[2]],
                                          subs.hd[[2]]),
                             HD.stat = c(males.hd[[1]],
                                         females.hd[[1]],
                                         doms.hd[[1]],
                                         subs.hd[[1]]),
                             CLX.p.val = c(males.CLX[[2]],
                                           females.CLX[[2]],
                                           doms.CLX[[2]],
                                           subs.CLX[[2]]),
                             CLX.stat = c(males.CLX[[1]],
                                          females.CLX[[1]],
                                          doms.CLX[[1]],
                                          subs.CLX[[1]]),
                             LC.p.val = c(males.LC$pval,
                                          females.LC$pval,
                                          doms.LC$pval,
                                          subs.LC$pval),
                             LC.stat = c(males.LC$stat,
                                         females.LC$stat,
                                         doms.LC$stat,
                                         subs.LC$stat)
)
results.testcov.all
